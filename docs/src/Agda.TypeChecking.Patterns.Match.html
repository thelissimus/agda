<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE NondecreasingIndentation #-}</span><span>
</span><span id="line-2"></span><span>
</span><span id="line-3"></span><span class="hs-comment">-- | Pattern matcher used in the reducer for clauses that</span><span>
</span><span id="line-4"></span><span class="hs-comment">--   have not been compiled to case trees yet.</span><span>
</span><span id="line-5"></span><span>
</span><span id="line-6"></span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html"><span class="hs-identifier">Agda.TypeChecking.Patterns.Match</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-7"></span><span>
</span><span id="line-8"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Prelude</span></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">null</span></span><span class="hs-special">)</span><span>
</span><span id="line-9"></span><span>
</span><span id="line-10"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span>
</span><span id="line-11"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.IntMap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">IntMap</span></span><span class="hs-special">)</span><span>
</span><span id="line-12"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.IntMap</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">IntMap</span></span><span>
</span><span id="line-13"></span><span>
</span><span id="line-14"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html"><span class="hs-identifier">Agda.Syntax.Common</span></a></span><span>
</span><span id="line-15"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html"><span class="hs-identifier">Agda.Syntax.Internal</span></a></span><span>
</span><span id="line-16"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.Pattern.html"><span class="hs-identifier">Agda.Syntax.Internal.Pattern</span></a></span><span>
</span><span id="line-17"></span><span>
</span><span id="line-18"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Reduce.html"><span class="hs-identifier">Agda.TypeChecking.Reduce</span></a></span><span>
</span><span id="line-19"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Reduce.Monad.html"><span class="hs-identifier">Agda.TypeChecking.Reduce.Monad</span></a></span><span>
</span><span id="line-20"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Substitute.html"><span class="hs-identifier">Agda.TypeChecking.Substitute</span></a></span><span>
</span><span id="line-21"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.html"><span class="hs-identifier">Agda.TypeChecking.Monad</span></a></span><span>
</span><span id="line-22"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Builtin.html"><span class="hs-identifier">Agda.TypeChecking.Monad.Builtin</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Monad.Builtin.html#getName%27"><span class="hs-identifier">getName'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.Syntax.Builtin.html#builtinHComp"><span class="hs-identifier">builtinHComp</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-23"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Pretty.html"><span class="hs-identifier">Agda.TypeChecking.Pretty</span></a></span><span>
</span><span id="line-24"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Records.html"><span class="hs-identifier">Agda.TypeChecking.Records</span></a></span><span>
</span><span id="line-25"></span><span>
</span><span id="line-26"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Utils.Empty.html"><span class="hs-identifier">Agda.Utils.Empty</span></a></span><span>
</span><span id="line-27"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Utils.Functor.html"><span class="hs-identifier">Agda.Utils.Functor</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Utils.Functor.html#for"><span class="hs-identifier">for</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-operator">($&gt;)</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-operator">(&lt;&amp;&gt;)</span></span><span class="hs-special">)</span><span>
</span><span id="line-28"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Utils.Maybe.html"><span class="hs-identifier">Agda.Utils.Maybe</span></a></span><span>
</span><span id="line-29"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Utils.Monad.html"><span class="hs-identifier">Agda.Utils.Monad</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Agda.Utils.Monad.html#anyM"><span class="hs-identifier">anyM</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.Utils.Monad.html#or2M"><span class="hs-identifier">or2M</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-30"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Utils.Null.html"><span class="hs-identifier">Agda.Utils.Null</span></a></span><span>
</span><span id="line-31"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Utils.Singleton.html"><span class="hs-identifier">Agda.Utils.Singleton</span></a></span><span>
</span><span id="line-32"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Utils.Size.html"><span class="hs-identifier">Agda.Utils.Size</span></a></span><span>
</span><span id="line-33"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Utils.Tuple.html"><span class="hs-identifier">Agda.Utils.Tuple</span></a></span><span>
</span><span id="line-34"></span><span>
</span><span id="line-35"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Agda.Utils.Impossible.html"><span class="hs-identifier">Agda.Utils.Impossible</span></a></span><span>
</span><span id="line-36"></span><span>
</span><span id="line-37"></span><span class="hs-comment">-- | If matching is inconclusive (@DontKnow@) we want to know whether it is on a</span><span>
</span><span id="line-38"></span><span class="hs-comment">--   lazy pattern and whether it is due to a particular meta variable.</span><span>
</span><span id="line-39"></span><span class="hs-keyword">data</span><span> </span><span id="Match"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-var">Match</span></a></span></span><span> </span><span id="local-6989586621682055685"><span class="annot"><a href="#local-6989586621682055685"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Yes"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-var">Yes</span></a></span></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Base.html#Simplification"><span class="hs-identifier hs-type">Simplification</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">IntMap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055685"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-40"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="No"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span></span><span>
</span><span id="line-41"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span id="DontKnow"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-var">DontKnow</span></a></span></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#OnlyLazy"><span class="hs-identifier hs-type">OnlyLazy</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Blocked"><span class="hs-identifier hs-type">Blocked</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-42"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span id="local-6989586621682055966"><span id="local-6989586621682055972"><span class="annot"><span class="annottext">(forall a b. (a -&gt; b) -&gt; Match a -&gt; Match b)
-&gt; (forall a b. a -&gt; Match b -&gt; Match a) -&gt; Functor Match
forall a b. a -&gt; Match b -&gt; Match a
forall a b. (a -&gt; b) -&gt; Match a -&gt; Match b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
$cfmap :: forall a b. (a -&gt; b) -&gt; Match a -&gt; Match b
fmap :: forall a b. (a -&gt; b) -&gt; Match a -&gt; Match b
$c&lt;$ :: forall a b. a -&gt; Match b -&gt; Match a
&lt;$ :: forall a b. a -&gt; Match b -&gt; Match a
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span>
</span><span id="line-43"></span><span>
</span><span id="line-44"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621682055682"><span class="annot"><a href="Agda.Utils.Null.html#Null"><span class="hs-identifier hs-type">Null</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055682"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-45"></span><span>  </span><span id="local-6989586621682055986"><span class="annot"><span class="annottext">empty :: Match a
</span><a href="#local-6989586621682055986"><span class="hs-identifier hs-var hs-var hs-var">empty</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Simplification -&gt; IntMap (Arg a) -&gt; Match a
forall a. Simplification -&gt; IntMap (Arg a) -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-var">Yes</span></a></span><span> </span><span class="annot"><span class="annottext">Simplification
forall a. Null a =&gt; a
</span><a href="Agda.Utils.Null.html#empty"><span class="hs-identifier hs-var">empty</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg a)
forall a. Null a =&gt; a
</span><a href="Agda.Utils.Null.html#empty"><span class="hs-identifier hs-var">empty</span></a></span><span>
</span><span id="line-46"></span><span>  </span><span id="local-6989586621682055990"><span class="annot"><span class="annottext">null :: Match a -&gt; Bool
</span><a href="#local-6989586621682055990"><span class="hs-identifier hs-var hs-var hs-var">null</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-type">Yes</span></a></span><span> </span><span id="local-6989586621682055992"><span class="annot"><span class="annottext">Simplification
</span><a href="#local-6989586621682055992"><span class="hs-identifier hs-var">simpl</span></a></span></span><span> </span><span id="local-6989586621682055993"><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621682055993"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Simplification -&gt; Bool
forall a. Null a =&gt; a -&gt; Bool
</span><a href="Agda.Utils.Null.html#null"><span class="hs-identifier hs-var">null</span></a></span><span> </span><span class="annot"><span class="annottext">Simplification
</span><a href="#local-6989586621682055992"><span class="hs-identifier hs-var">simpl</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg a) -&gt; Bool
forall a. Null a =&gt; a -&gt; Bool
</span><a href="Agda.Utils.Null.html#null"><span class="hs-identifier hs-var">null</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621682055993"><span class="hs-keyword hs-var">as</span></a></span><span>
</span><span id="line-47"></span><span>  </span><span class="annot"><a href="Agda.Utils.Null.html#null"><span class="hs-identifier hs-var">null</span></a></span><span> </span><span class="annot"><span class="annottext">Match a
</span><span class="hs-identifier">_</span></span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-48"></span><span>
</span><span id="line-49"></span><span id="local-6989586621682055687"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchedArgs"><span class="hs-identifier hs-type">matchedArgs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.Utils.Empty.html#Empty"><span class="hs-identifier hs-type">Empty</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IntMap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055687"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055687"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-50"></span><span id="matchedArgs"><span class="annot"><span class="annottext">matchedArgs :: forall a. Empty -&gt; Int -&gt; IntMap (Arg a) -&gt; [Arg a]
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchedArgs"><span class="hs-identifier hs-var hs-var">matchedArgs</span></a></span></span><span> </span><span id="local-6989586621682055996"><span class="annot"><span class="annottext">Empty
</span><a href="#local-6989586621682055996"><span class="hs-identifier hs-var">err</span></a></span></span><span> </span><span id="local-6989586621682055997"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621682055997"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621682055998"><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621682055998"><span class="hs-identifier hs-var">vs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Maybe (Arg a) -&gt; Arg a) -&gt; [Maybe (Arg a)] -&gt; [Arg a]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Arg a -&gt; Maybe (Arg a) -&gt; Arg a
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Empty -&gt; Arg a
forall a. Empty -&gt; a
</span><a href="Agda.Utils.Empty.html#absurd"><span class="hs-identifier hs-var">absurd</span></a></span><span> </span><span class="annot"><span class="annottext">Empty
</span><a href="#local-6989586621682055996"><span class="hs-identifier hs-var">err</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">([Maybe (Arg a)] -&gt; [Arg a]) -&gt; [Maybe (Arg a)] -&gt; [Arg a]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; IntMap (Arg a) -&gt; [Maybe (Arg a)]
forall a. Int -&gt; IntMap (Arg a) -&gt; [Maybe (Arg a)]
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchedArgs%27"><span class="hs-identifier hs-var">matchedArgs'</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621682055997"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621682055998"><span class="hs-identifier hs-var">vs</span></a></span><span>
</span><span id="line-51"></span><span>
</span><span id="line-52"></span><span id="local-6989586621682055697"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchedArgs%27"><span class="hs-identifier hs-type">matchedArgs'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IntMap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055697"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055697"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span></span><span>
</span><span id="line-53"></span><span id="matchedArgs%27"><span class="annot"><span class="annottext">matchedArgs' :: forall a. Int -&gt; IntMap (Arg a) -&gt; [Maybe (Arg a)]
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchedArgs%27"><span class="hs-identifier hs-var hs-var">matchedArgs'</span></a></span></span><span> </span><span id="local-6989586621682056008"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621682056008"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621682056009"><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621682056009"><span class="hs-identifier hs-var">vs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Int -&gt; Maybe (Arg a)) -&gt; [Int] -&gt; [Maybe (Arg a)]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Maybe (Arg a)
</span><a href="#local-6989586621682056010"><span class="hs-identifier hs-var">get</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">..</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621682056008"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">]</span><span>
</span><span id="line-54"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-55"></span><span>    </span><span id="local-6989586621682056010"><span class="annot"><span class="annottext">get :: Int -&gt; Maybe (Arg a)
</span><a href="#local-6989586621682056010"><span class="hs-identifier hs-var hs-var">get</span></a></span></span><span> </span><span id="local-6989586621682056011"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621682056011"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; IntMap (Arg a) -&gt; Maybe (Arg a)
forall a. Int -&gt; IntMap a -&gt; Maybe a
</span><span class="hs-identifier hs-var">IntMap.lookup</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621682056011"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621682056009"><span class="hs-identifier hs-var">vs</span></a></span><span>
</span><span id="line-56"></span><span>
</span><span id="line-57"></span><span class="annot"><span class="hs-comment">-- | Builds a proper substitution from an IntMap produced by match(Co)patterns</span></span><span>
</span><span id="line-58"></span><span id="local-6989586621682055702"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#buildSubstitution"><span class="hs-identifier hs-type">buildSubstitution</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Substitute.DeBruijn.html#DeBruijn"><span class="hs-identifier hs-type">DeBruijn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055702"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-59"></span><span>                  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Agda.Utils.Impossible.html#Impossible"><span class="hs-identifier hs-type">Impossible</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IntMap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055702"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Substitution%27"><span class="hs-identifier hs-type">Substitution'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055702"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-60"></span><span id="buildSubstitution"><span class="annot"><span class="annottext">buildSubstitution :: forall a.
DeBruijn a =&gt;
Impossible -&gt; Int -&gt; IntMap (Arg a) -&gt; Substitution' a
</span><a href="Agda.TypeChecking.Patterns.Match.html#buildSubstitution"><span class="hs-identifier hs-var hs-var">buildSubstitution</span></a></span></span><span> </span><span id="local-6989586621682056018"><span class="annot"><span class="annottext">Impossible
</span><a href="#local-6989586621682056018"><span class="hs-identifier hs-var">err</span></a></span></span><span> </span><span id="local-6989586621682056019"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621682056019"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621682056020"><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621682056020"><span class="hs-identifier hs-var">vs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Maybe (Arg a) -&gt; Substitution' a -&gt; Substitution' a)
-&gt; Substitution' a -&gt; [Maybe (Arg a)] -&gt; Substitution' a
forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="annot"><span class="annottext">Maybe (Arg a) -&gt; Substitution' a -&gt; Substitution' a
</span><a href="#local-6989586621682056022"><span class="hs-identifier hs-var">cons</span></a></span><span> </span><span class="annot"><span class="annottext">Substitution' a
forall a. Substitution' a
</span><a href="Agda.TypeChecking.Substitute.Class.html#idS"><span class="hs-identifier hs-var">idS</span></a></span><span> </span><span class="annot"><span class="annottext">([Maybe (Arg a)] -&gt; Substitution' a)
-&gt; [Maybe (Arg a)] -&gt; Substitution' a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; IntMap (Arg a) -&gt; [Maybe (Arg a)]
forall a. Int -&gt; IntMap (Arg a) -&gt; [Maybe (Arg a)]
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchedArgs%27"><span class="hs-identifier hs-var">matchedArgs'</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621682056019"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621682056020"><span class="hs-identifier hs-var">vs</span></a></span><span>
</span><span id="line-61"></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621682056022"><span class="annot"><span class="annottext">cons :: Maybe (Arg a) -&gt; Substitution' a -&gt; Substitution' a
</span><a href="#local-6989586621682056022"><span class="hs-identifier hs-var hs-var">cons</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe (Arg a)
</span><span class="hs-identifier hs-var">Nothing</span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Impossible -&gt; Int -&gt; Substitution' a -&gt; Substitution' a
forall a. Impossible -&gt; Int -&gt; Substitution' a -&gt; Substitution' a
</span><a href="Agda.TypeChecking.Substitute.Class.html#strengthenS%27"><span class="hs-identifier hs-var">strengthenS'</span></a></span><span> </span><span class="annot"><span class="annottext">Impossible
</span><a href="#local-6989586621682056018"><span class="hs-identifier hs-var">err</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span>
</span><span id="line-62"></span><span>        </span><span class="annot"><a href="#local-6989586621682056022"><span class="hs-identifier hs-var">cons</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621682056025"><span class="annot"><span class="annottext">Arg a
</span><a href="#local-6989586621682056025"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; Substitution' a -&gt; Substitution' a
forall a. DeBruijn a =&gt; a -&gt; Substitution' a -&gt; Substitution' a
</span><a href="Agda.TypeChecking.Substitute.Class.html#consS"><span class="hs-identifier hs-var">consS</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Arg a -&gt; a
forall e. Arg e -&gt; e
</span><a href="Agda.Syntax.Common.html#unArg"><span class="hs-identifier hs-var">unArg</span></a></span><span> </span><span class="annot"><span class="annottext">Arg a
</span><a href="#local-6989586621682056025"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-63"></span><span>
</span><span id="line-64"></span><span>
</span><span id="line-65"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621682055718"><span id="local-6989586621682056030"><span id="local-6989586621682056034"><span class="annot"><span class="hs-identifier hs-type">Semigroup</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055718"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-66"></span><span>    </span><span class="hs-comment">-- @NotBlocked (StuckOn e)@ means blocked by a variable.</span><span>
</span><span id="line-67"></span><span>    </span><span class="hs-comment">-- In this case, no instantiation of meta-variables will make progress.</span><span>
</span><span id="line-68"></span><span>    </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-type">DontKnow</span></a></span><span> </span><span id="local-6989586621682056049"><span class="annot"><span class="annottext">OnlyLazy
</span><a href="#local-6989586621682056049"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621682056050"><span class="annot"><span class="annottext">Blocked ()
</span><a href="#local-6989586621682056050"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span id="local-6989586621682056051"><span class="annot"><span class="annottext">&lt;&gt; :: Match a -&gt; Match a -&gt; Match a
</span><span class="hs-operator hs-var hs-var hs-var">&lt;&gt;</span></span></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-type">DontKnow</span></a></span><span> </span><span id="local-6989586621682056052"><span class="annot"><span class="annottext">OnlyLazy
</span><a href="#local-6989586621682056052"><span class="hs-identifier hs-var">l'</span></a></span></span><span> </span><span id="local-6989586621682056053"><span class="annot"><span class="annottext">Blocked ()
</span><a href="#local-6989586621682056053"><span class="hs-identifier hs-var">b'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OnlyLazy -&gt; Blocked () -&gt; Match a
forall a. OnlyLazy -&gt; Blocked () -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-var">DontKnow</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">OnlyLazy
</span><a href="#local-6989586621682056049"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">OnlyLazy -&gt; OnlyLazy -&gt; OnlyLazy
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">OnlyLazy
</span><a href="#local-6989586621682056052"><span class="hs-identifier hs-var">l'</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Blocked ()
</span><a href="#local-6989586621682056050"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="annot"><span class="annottext">Blocked () -&gt; Blocked () -&gt; Blocked ()
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Blocked ()
</span><a href="#local-6989586621682056053"><span class="hs-identifier hs-var">b'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-69"></span><span>    </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-type">DontKnow</span></a></span><span> </span><span id="local-6989586621682056054"><span class="annot"><span class="annottext">OnlyLazy
</span><a href="#local-6989586621682056054"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621682056055"><span class="annot"><span class="annottext">Blocked ()
</span><a href="#local-6989586621682056055"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Match a
</span><span class="hs-identifier">_</span></span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OnlyLazy -&gt; Blocked () -&gt; Match a
forall a. OnlyLazy -&gt; Blocked () -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-var">DontKnow</span></a></span><span> </span><span class="annot"><span class="annottext">OnlyLazy
</span><a href="#local-6989586621682056054"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">Blocked ()
</span><a href="#local-6989586621682056055"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-70"></span><span>    </span><span class="annot"><span class="annottext">Match a
</span><span class="hs-identifier">_</span></span><span>            </span><span class="annot"><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-type">DontKnow</span></a></span><span> </span><span id="local-6989586621682056056"><span class="annot"><span class="annottext">OnlyLazy
</span><a href="#local-6989586621682056056"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621682056057"><span class="annot"><span class="annottext">Blocked ()
</span><a href="#local-6989586621682056057"><span class="hs-identifier hs-var">m</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OnlyLazy -&gt; Blocked () -&gt; Match a
forall a. OnlyLazy -&gt; Blocked () -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-var">DontKnow</span></a></span><span> </span><span class="annot"><span class="annottext">OnlyLazy
</span><a href="#local-6989586621682056056"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">Blocked ()
</span><a href="#local-6989586621682056057"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-71"></span><span>    </span><span class="hs-comment">-- One could imagine DontKnow _ _ &lt;&gt; No = No, but would break the</span><span>
</span><span id="line-72"></span><span>    </span><span class="hs-comment">-- equivalence to case-trees (Issue 2964).</span><span>
</span><span id="line-73"></span><span>    </span><span class="annot"><span class="annottext">Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span>         </span><span class="annot"><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Match a
</span><span class="hs-identifier">_</span></span><span>                </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Match a
forall a. Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span>
</span><span id="line-74"></span><span>    </span><span class="annot"><span class="annottext">Match a
</span><span class="hs-identifier">_</span></span><span>          </span><span class="annot"><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span>               </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Match a
forall a. Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span>
</span><span id="line-75"></span><span>    </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-type">Yes</span></a></span><span> </span><span id="local-6989586621682056058"><span class="annot"><span class="annottext">Simplification
</span><a href="#local-6989586621682056058"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span id="local-6989586621682056059"><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621682056059"><span class="hs-identifier hs-var">us</span></a></span></span><span>   </span><span class="annot"><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-type">Yes</span></a></span><span> </span><span id="local-6989586621682056060"><span class="annot"><span class="annottext">Simplification
</span><a href="#local-6989586621682056060"><span class="hs-identifier hs-var">s'</span></a></span></span><span> </span><span id="local-6989586621682056061"><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621682056061"><span class="hs-identifier hs-var">vs</span></a></span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Simplification -&gt; IntMap (Arg a) -&gt; Match a
forall a. Simplification -&gt; IntMap (Arg a) -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-var">Yes</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Simplification
</span><a href="#local-6989586621682056058"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="annot"><span class="annottext">Simplification -&gt; Simplification -&gt; Simplification
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">Simplification
</span><a href="#local-6989586621682056060"><span class="hs-identifier hs-var">s'</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621682056059"><span class="hs-identifier hs-var">us</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg a) -&gt; IntMap (Arg a) -&gt; IntMap (Arg a)
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621682056061"><span class="hs-identifier hs-var">vs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-76"></span><span>
</span><span id="line-77"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621682055727"><span id="local-6989586621682056067"><span class="annot"><span class="hs-identifier hs-type">Monoid</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055727"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-78"></span><span>    </span><span id="local-6989586621682056072"><span class="annot"><span class="annottext">mempty :: Match a
</span><span class="hs-identifier hs-var hs-var hs-var">mempty</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Match a
forall a. Null a =&gt; a
</span><a href="Agda.Utils.Null.html#empty"><span class="hs-identifier hs-var">empty</span></a></span><span>
</span><span id="line-79"></span><span>    </span><span id="local-6989586621682056074"><span class="annot"><span class="annottext">mappend :: Match a -&gt; Match a -&gt; Match a
</span><span class="hs-identifier hs-var hs-var hs-var">mappend</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Match a -&gt; Match a -&gt; Match a
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">(&lt;&gt;)</span></span><span>
</span><span id="line-80"></span><span>
</span><span id="line-81"></span><span class="annot"><span class="hs-comment">-- | Whether the inconclusive matches are only on lazy patterns.</span></span><span>
</span><span id="line-82"></span><span class="hs-keyword">data</span><span> </span><span id="OnlyLazy"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#OnlyLazy"><span class="hs-identifier hs-var">OnlyLazy</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="OnlyLazy"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#OnlyLazy"><span class="hs-identifier hs-var">OnlyLazy</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="NonLazy"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#NonLazy"><span class="hs-identifier hs-var">NonLazy</span></a></span></span><span>
</span><span id="line-83"></span><span>
</span><span id="line-84"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621682056079"><span id="local-6989586621682056082"><span class="annot"><span class="hs-identifier hs-type">Semigroup</span></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#OnlyLazy"><span class="hs-identifier hs-type">OnlyLazy</span></a></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-85"></span><span>  </span><span class="annot"><span class="annottext">OnlyLazy
</span><a href="Agda.TypeChecking.Patterns.Match.html#NonLazy"><span class="hs-identifier hs-var">NonLazy</span></a></span><span>  </span><span id="local-6989586621682056086"><span class="annot"><span class="annottext">&lt;&gt; :: OnlyLazy -&gt; OnlyLazy -&gt; OnlyLazy
</span><span class="hs-operator hs-var hs-var hs-var">&lt;&gt;</span></span></span><span> </span><span class="annot"><span class="annottext">OnlyLazy
</span><span class="hs-identifier">_</span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OnlyLazy
</span><a href="Agda.TypeChecking.Patterns.Match.html#NonLazy"><span class="hs-identifier hs-var">NonLazy</span></a></span><span>
</span><span id="line-86"></span><span>  </span><span class="annot"><span class="annottext">OnlyLazy
</span><span class="hs-identifier">_</span></span><span>        </span><span class="annot"><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">OnlyLazy
</span><a href="Agda.TypeChecking.Patterns.Match.html#NonLazy"><span class="hs-identifier hs-var">NonLazy</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OnlyLazy
</span><a href="Agda.TypeChecking.Patterns.Match.html#NonLazy"><span class="hs-identifier hs-var">NonLazy</span></a></span><span>
</span><span id="line-87"></span><span>  </span><span class="annot"><span class="annottext">OnlyLazy
</span><a href="Agda.TypeChecking.Patterns.Match.html#OnlyLazy"><span class="hs-identifier hs-var">OnlyLazy</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-var">&lt;&gt;</span></span><span> </span><span class="annot"><span class="annottext">OnlyLazy
</span><a href="Agda.TypeChecking.Patterns.Match.html#OnlyLazy"><span class="hs-identifier hs-var">OnlyLazy</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OnlyLazy
</span><a href="Agda.TypeChecking.Patterns.Match.html#OnlyLazy"><span class="hs-identifier hs-var">OnlyLazy</span></a></span><span>
</span><span id="line-88"></span><span>
</span><span id="line-89"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621682056092"><span class="annot"><span class="hs-identifier hs-type">Monoid</span></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#OnlyLazy"><span class="hs-identifier hs-type">OnlyLazy</span></a></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-90"></span><span>  </span><span id="local-6989586621682056095"><span class="annot"><span class="annottext">mempty :: OnlyLazy
</span><span class="hs-identifier hs-var hs-var hs-var">mempty</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OnlyLazy
</span><a href="Agda.TypeChecking.Patterns.Match.html#OnlyLazy"><span class="hs-identifier hs-var">OnlyLazy</span></a></span><span>
</span><span id="line-91"></span><span>  </span><span id="local-6989586621682056097"><span class="annot"><span class="annottext">mappend :: OnlyLazy -&gt; OnlyLazy -&gt; OnlyLazy
</span><span class="hs-identifier hs-var hs-var hs-var">mappend</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">OnlyLazy -&gt; OnlyLazy -&gt; OnlyLazy
forall a. Semigroup a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">(&lt;&gt;)</span></span><span>
</span><span id="line-92"></span><span>
</span><span id="line-93"></span><span class="hs-comment">-- | Instead of 'zipWithM', we need to use this lazy version</span><span>
</span><span id="line-94"></span><span class="hs-comment">--   of combining pattern matching computations.</span><span>
</span><span id="line-95"></span><span>
</span><span id="line-96"></span><span class="hs-comment">-- Andreas, 2014-05-08, see Issue 1124:</span><span>
</span><span id="line-97"></span><span class="hs-comment">--</span><span>
</span><span id="line-98"></span><span class="hs-comment">-- Due to a bug in TypeChecking.Patterns.Match</span><span>
</span><span id="line-99"></span><span class="hs-comment">-- a failed match of (C n b) against (C O unit)</span><span>
</span><span id="line-100"></span><span class="hs-comment">-- turned into (C n unit).</span><span>
</span><span id="line-101"></span><span class="hs-comment">-- This was because all patterns were matched in</span><span>
</span><span id="line-102"></span><span class="hs-comment">-- parallel, and evaluations of successfull matches</span><span>
</span><span id="line-103"></span><span class="hs-comment">-- (and a record constructor like unit can always</span><span>
</span><span id="line-104"></span><span class="hs-comment">-- be successfully matched) were returned, leading</span><span>
</span><span id="line-105"></span><span class="hs-comment">-- to a reassembly of (C n b) as (C n unit) which is</span><span>
</span><span id="line-106"></span><span class="hs-comment">-- illtyped.</span><span>
</span><span id="line-107"></span><span>
</span><span id="line-108"></span><span class="hs-comment">-- Now patterns are matched left to right and</span><span>
</span><span id="line-109"></span><span class="hs-comment">-- upon failure, no further matching is performed.</span><span>
</span><span id="line-110"></span><span>
</span><span id="line-111"></span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#foldMatch"><span class="hs-identifier hs-type">foldMatch</span></a></span><span>
</span><span id="line-112"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621682055731"><span class="annot"><a href="#local-6989586621682055731"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span id="local-6989586621682055729"><span class="annot"><a href="#local-6989586621682055729"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span id="local-6989586621682055732"><span class="annot"><a href="#local-6989586621682055732"><span class="hs-identifier hs-type">v</span></a></span></span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Abstract.Name.html#IsProjP"><span class="hs-identifier hs-type">IsProjP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055729"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#MonadMatch"><span class="hs-identifier hs-type">MonadMatch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055731"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-113"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621682055729"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682055732"><span class="hs-identifier hs-type">v</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682055731"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621682055732"><span class="hs-identifier hs-type">v</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-114"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621682055729"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621682055732"><span class="hs-identifier hs-type">v</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682055731"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621682055732"><span class="hs-identifier hs-type">v</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-115"></span><span id="foldMatch"><span class="annot"><span class="annottext">foldMatch :: forall (m :: * -&gt; *) p v.
(IsProjP p, MonadMatch m) =&gt;
(p -&gt; v -&gt; m (Match Term, v)) -&gt; [p] -&gt; [v] -&gt; m (Match Term, [v])
</span><a href="Agda.TypeChecking.Patterns.Match.html#foldMatch"><span class="hs-identifier hs-var hs-var">foldMatch</span></a></span></span><span> </span><span id="local-6989586621682056123"><span class="annot"><span class="annottext">p -&gt; v -&gt; m (Match Term, v)
</span><a href="#local-6989586621682056123"><span class="hs-identifier hs-var">match</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[p] -&gt; [v] -&gt; m (Match Term, [v])
</span><a href="#local-6989586621682056124"><span class="hs-identifier hs-var">loop</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-116"></span><span>  </span><span class="annot"><a href="#local-6989586621682056124"><span class="hs-identifier hs-type">loop</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621682055729"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621682055732"><span class="hs-identifier hs-type">v</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682055731"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621682055732"><span class="hs-identifier hs-type">v</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-117"></span><span>  </span><span id="local-6989586621682056124"><span class="annot"><span class="annottext">loop :: [p] -&gt; [v] -&gt; m (Match Term, [v])
</span><a href="#local-6989586621682056124"><span class="hs-identifier hs-var hs-var">loop</span></a></span></span><span> </span><span id="local-6989586621682056125"><span class="annot"><span class="annottext">[p]
</span><a href="#local-6989586621682056125"><span class="hs-identifier hs-var">ps0</span></a></span></span><span> </span><span id="local-6989586621682056126"><span class="annot"><span class="annottext">[v]
</span><a href="#local-6989586621682056126"><span class="hs-identifier hs-var">vs0</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-118"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[p]
</span><a href="#local-6989586621682056125"><span class="hs-identifier hs-var">ps0</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[v]
</span><a href="#local-6989586621682056126"><span class="hs-identifier hs-var">vs0</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-119"></span><span>      </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, [v]) -&gt; m (Match Term, [v])
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Match Term
forall a. Null a =&gt; a
</span><a href="Agda.Utils.Null.html#empty"><span class="hs-identifier hs-var">empty</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-120"></span><span>      </span><span class="hs-special">(</span><span id="local-6989586621682056127"><span class="annot"><span class="annottext">p
</span><a href="#local-6989586621682056127"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621682056128"><span class="annot"><span class="annottext">[p]
</span><a href="#local-6989586621682056128"><span class="hs-identifier hs-var">ps</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621682056129"><span class="annot"><span class="annottext">v
</span><a href="#local-6989586621682056129"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621682056130"><span class="annot"><span class="annottext">[v]
</span><a href="#local-6989586621682056130"><span class="hs-identifier hs-var">vs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-121"></span><span>        </span><span class="hs-special">(</span><span id="local-6989586621682056131"><span class="annot"><a href="#local-6989586621682056131"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621682056132"><span class="annot"><a href="#local-6989586621682056132"><span class="hs-identifier hs-var">v'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">p -&gt; v -&gt; m (Match Term, v)
</span><a href="#local-6989586621682056123"><span class="hs-identifier hs-var">match</span></a></span><span> </span><span class="annot"><span class="annottext">p
</span><a href="#local-6989586621682056127"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">v
</span><a href="#local-6989586621682056129"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-122"></span><span>        </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="#local-6989586621682056131"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-123"></span><span>          </span><span class="annot"><span class="annottext">Match Term
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">p -&gt; Maybe (ProjOrigin, AmbiguousQName)
forall a. IsProjP a =&gt; a -&gt; Maybe (ProjOrigin, AmbiguousQName)
</span><a href="Agda.Syntax.Abstract.Name.html#isProjP"><span class="hs-identifier hs-var">isProjP</span></a></span><span> </span><span class="annot"><span class="annottext">p
</span><a href="#local-6989586621682056127"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, [v]) -&gt; m (Match Term, [v])
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Match Term
forall a. Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">v
</span><a href="#local-6989586621682056132"><span class="hs-identifier hs-var">v'</span></a></span><span> </span><span class="annot"><span class="annottext">v -&gt; [v] -&gt; [v]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[v]
</span><a href="#local-6989586621682056130"><span class="hs-identifier hs-var">vs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-124"></span><span>          </span><span class="annot"><span class="annottext">Match Term
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-125"></span><span>            </span><span class="hs-comment">-- Issue 2964: Even when the first pattern doesn't match we should</span><span>
</span><span id="line-126"></span><span>            </span><span class="hs-comment">-- continue to the next patterns (and potentially block on them)</span><span>
</span><span id="line-127"></span><span>            </span><span class="hs-comment">-- because the splitting order in the case tree may not be</span><span>
</span><span id="line-128"></span><span>            </span><span class="hs-comment">-- left-to-right.</span><span>
</span><span id="line-129"></span><span>            </span><span class="hs-special">(</span><span id="local-6989586621682056134"><span class="annot"><a href="#local-6989586621682056134"><span class="hs-identifier hs-var">r'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621682056135"><span class="annot"><a href="#local-6989586621682056135"><span class="hs-identifier hs-var">_vs'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[p] -&gt; [v] -&gt; m (Match Term, [v])
</span><a href="#local-6989586621682056124"><span class="hs-identifier hs-var">loop</span></a></span><span> </span><span class="annot"><span class="annottext">[p]
</span><a href="#local-6989586621682056128"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="annot"><span class="annottext">[v]
</span><a href="#local-6989586621682056130"><span class="hs-identifier hs-var">vs</span></a></span><span>
</span><span id="line-130"></span><span>            </span><span class="hs-comment">-- Issue 2968: do not use vs' here, because it might</span><span>
</span><span id="line-131"></span><span>            </span><span class="hs-comment">-- contain ill-typed terms due to eta-expansion at wrong</span><span>
</span><span id="line-132"></span><span>            </span><span class="hs-comment">-- type.</span><span>
</span><span id="line-133"></span><span>            </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621682056131"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621682056134"><span class="hs-identifier hs-type">r'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621682056132"><span class="hs-identifier hs-type">v'</span></a></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span class="annot"><a href="#local-6989586621682056130"><span class="hs-identifier hs-type">vs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-134"></span><span>          </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-type">DontKnow</span></a></span><span> </span><span class="annot"><span class="annottext">OnlyLazy
</span><a href="Agda.TypeChecking.Patterns.Match.html#OnlyLazy"><span class="hs-identifier hs-var">OnlyLazy</span></a></span><span> </span><span class="annot"><span class="annottext">Blocked ()
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-135"></span><span>            </span><span class="hs-special">(</span><span id="local-6989586621682056136"><span class="annot"><a href="#local-6989586621682056136"><span class="hs-identifier hs-var">r'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621682056137"><span class="annot"><a href="#local-6989586621682056137"><span class="hs-identifier hs-var">_vs'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[p] -&gt; [v] -&gt; m (Match Term, [v])
</span><a href="#local-6989586621682056124"><span class="hs-identifier hs-var">loop</span></a></span><span> </span><span class="annot"><span class="annottext">[p]
</span><a href="#local-6989586621682056128"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="annot"><span class="annottext">[v]
</span><a href="#local-6989586621682056130"><span class="hs-identifier hs-var">vs</span></a></span><span>
</span><span id="line-136"></span><span>            </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621682056131"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621682056136"><span class="hs-identifier hs-type">r'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621682056132"><span class="hs-identifier hs-type">v'</span></a></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span class="annot"><a href="#local-6989586621682056130"><span class="hs-identifier hs-type">vs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-137"></span><span>          </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-type">DontKnow</span></a></span><span> </span><span class="annot"><span class="annottext">OnlyLazy
</span><a href="Agda.TypeChecking.Patterns.Match.html#NonLazy"><span class="hs-identifier hs-var">NonLazy</span></a></span><span> </span><span id="local-6989586621682056138"><span class="annot"><span class="annottext">Blocked ()
</span><a href="#local-6989586621682056138"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, [v]) -&gt; m (Match Term, [v])
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">OnlyLazy -&gt; Blocked () -&gt; Match Term
forall a. OnlyLazy -&gt; Blocked () -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-var">DontKnow</span></a></span><span> </span><span class="annot"><span class="annottext">OnlyLazy
</span><a href="Agda.TypeChecking.Patterns.Match.html#NonLazy"><span class="hs-identifier hs-var">NonLazy</span></a></span><span> </span><span class="annot"><span class="annottext">Blocked ()
</span><a href="#local-6989586621682056138"><span class="hs-identifier hs-var">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">v
</span><a href="#local-6989586621682056132"><span class="hs-identifier hs-var">v'</span></a></span><span> </span><span class="annot"><span class="annottext">v -&gt; [v] -&gt; [v]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[v]
</span><a href="#local-6989586621682056130"><span class="hs-identifier hs-var">vs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-138"></span><span>          </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-type">Yes</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-139"></span><span>            </span><span class="hs-special">(</span><span id="local-6989586621682056139"><span class="annot"><a href="#local-6989586621682056139"><span class="hs-identifier hs-var">r'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621682056140"><span class="annot"><a href="#local-6989586621682056140"><span class="hs-identifier hs-var">vs'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[p] -&gt; [v] -&gt; m (Match Term, [v])
</span><a href="#local-6989586621682056124"><span class="hs-identifier hs-var">loop</span></a></span><span> </span><span class="annot"><span class="annottext">[p]
</span><a href="#local-6989586621682056128"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="annot"><span class="annottext">[v]
</span><a href="#local-6989586621682056130"><span class="hs-identifier hs-var">vs</span></a></span><span>
</span><span id="line-140"></span><span>            </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621682056131"><span class="hs-identifier hs-type">r</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621682056139"><span class="hs-identifier hs-type">r'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621682056132"><span class="hs-identifier hs-type">v'</span></a></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span class="annot"><a href="#local-6989586621682056140"><span class="hs-identifier hs-type">vs'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-141"></span><span>      </span><span class="annot"><span class="annottext">([p], [v])
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match Term, [v])
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>
</span><span id="line-142"></span><span>
</span><span id="line-143"></span><span>
</span><span id="line-144"></span><span class="hs-comment">-- TODO refactor matchPattern* to work with Elim instead.</span><span>
</span><span id="line-145"></span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#mergeElim"><span class="hs-identifier hs-type">mergeElim</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Elim"><span class="hs-identifier hs-type">Elim</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Elim"><span class="hs-identifier hs-type">Elim</span></a></span><span>
</span><span id="line-146"></span><span id="mergeElim"><span class="annot"><span class="annottext">mergeElim :: Elim -&gt; Arg Term -&gt; Elim
</span><a href="Agda.TypeChecking.Patterns.Match.html#mergeElim"><span class="hs-identifier hs-var hs-var">mergeElim</span></a></span></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.Elim.html#Apply"><span class="hs-identifier hs-type">Apply</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span id="local-6989586621682056144"><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056144"><span class="hs-identifier hs-var">arg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Arg Term -&gt; Elim
forall a. Arg a -&gt; Elim' a
</span><a href="Agda.Syntax.Internal.Elim.html#Apply"><span class="hs-identifier hs-var">Apply</span></a></span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056144"><span class="hs-identifier hs-var">arg</span></a></span><span>
</span><span id="line-147"></span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#mergeElim"><span class="hs-identifier hs-var">mergeElim</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.Elim.html#IApply"><span class="hs-identifier hs-type">IApply</span></a></span><span> </span><span id="local-6989586621682056146"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056146"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621682056147"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056147"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621682056148"><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056148"><span class="hs-identifier hs-var">arg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Term -&gt; Term -&gt; Term -&gt; Elim
forall a. a -&gt; a -&gt; a -&gt; Elim' a
</span><a href="Agda.Syntax.Internal.Elim.html#IApply"><span class="hs-identifier hs-var">IApply</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056146"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056147"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Arg Term -&gt; Term
forall e. Arg e -&gt; e
</span><a href="Agda.Syntax.Common.html#unArg"><span class="hs-identifier hs-var">unArg</span></a></span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056148"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-148"></span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#mergeElim"><span class="hs-identifier hs-var">mergeElim</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.Elim.html#Proj"><span class="hs-identifier hs-type">Proj</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Elim
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>
</span><span id="line-149"></span><span>
</span><span id="line-150"></span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#mergeElims"><span class="hs-identifier hs-type">mergeElims</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Internal.html#Elim"><span class="hs-identifier hs-type">Elim</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Internal.html#Elim"><span class="hs-identifier hs-type">Elim</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-151"></span><span id="mergeElims"><span class="annot"><span class="annottext">mergeElims :: [Elim] -&gt; [Arg Term] -&gt; [Elim]
</span><a href="Agda.TypeChecking.Patterns.Match.html#mergeElims"><span class="hs-identifier hs-var hs-var">mergeElims</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Elim -&gt; Arg Term -&gt; Elim) -&gt; [Elim] -&gt; [Arg Term] -&gt; [Elim]
forall a b c. (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
</span><span class="hs-identifier hs-var">zipWith</span></span><span> </span><span class="annot"><span class="annottext">Elim -&gt; Arg Term -&gt; Elim
</span><a href="Agda.TypeChecking.Patterns.Match.html#mergeElim"><span class="hs-identifier hs-var">mergeElim</span></a></span><span>
</span><span id="line-152"></span><span>
</span><span id="line-153"></span><span class="hs-keyword">type</span><span> </span><span id="MonadMatch"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#MonadMatch"><span class="hs-identifier hs-var">MonadMatch</span></a></span></span><span> </span><span id="local-6989586621682056152"><span class="annot"><a href="#local-6989586621682056152"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Pure.html#PureTCM"><span class="hs-identifier hs-type">PureTCM</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682056152"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-154"></span><span>
</span><span id="line-155"></span><span class="hs-comment">-- | @matchCopatterns ps es@ matches spine @es@ against copattern spine @ps@.</span><span>
</span><span id="line-156"></span><span class="hs-comment">--</span><span>
</span><span id="line-157"></span><span class="hs-comment">--   Returns 'Yes' and a substitution for the pattern variables</span><span>
</span><span id="line-158"></span><span class="hs-comment">--   (in form of IntMap Term) if matching was successful.</span><span>
</span><span id="line-159"></span><span class="hs-comment">--</span><span>
</span><span id="line-160"></span><span class="hs-comment">--   Returns 'No' if there was a constructor or projection mismatch.</span><span>
</span><span id="line-161"></span><span class="hs-comment">--</span><span>
</span><span id="line-162"></span><span class="hs-comment">--   Returns 'DontKnow' if an argument could not be evaluated to</span><span>
</span><span id="line-163"></span><span class="hs-comment">--   constructor form because of a blocking meta variable.</span><span>
</span><span id="line-164"></span><span class="hs-comment">--</span><span>
</span><span id="line-165"></span><span class="hs-comment">--   In any case, also returns spine @es@ in reduced form</span><span>
</span><span id="line-166"></span><span class="hs-comment">--   (with all the weak head reductions performed that were necessary</span><span>
</span><span id="line-167"></span><span class="hs-comment">--   to come to a decision).</span><span>
</span><span id="line-168"></span><span id="local-6989586621682055754"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchCopatterns"><span class="hs-identifier hs-type">matchCopatterns</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#MonadMatch"><span class="hs-identifier hs-type">MonadMatch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055754"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-169"></span><span>                </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Common.html#NamedArg"><span class="hs-identifier hs-type">NamedArg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-identifier hs-type">DeBruijnPattern</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-170"></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Internal.html#Elim"><span class="hs-identifier hs-type">Elim</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-171"></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682055754"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Internal.html#Elim"><span class="hs-identifier hs-type">Elim</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span></span><span>
</span><span id="line-172"></span><span id="matchCopatterns"><span class="annot"><span class="annottext">matchCopatterns :: forall (m :: * -&gt; *).
MonadMatch m =&gt;
[NamedArg DeBruijnPattern] -&gt; [Elim] -&gt; m (Match Term, [Elim])
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchCopatterns"><span class="hs-identifier hs-var hs-var">matchCopatterns</span></a></span></span><span> </span><span id="local-6989586621682056221"><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621682056221"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span id="local-6989586621682056222"><span class="annot"><span class="annottext">[Elim]
</span><a href="#local-6989586621682056222"><span class="hs-identifier hs-var">vs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-173"></span><span>  </span><span class="annot"><span class="annottext">VerboseKey
-&gt; Int
-&gt; TCMT IO Doc
-&gt; m (Match Term, [Elim])
-&gt; m (Match Term, [Elim])
forall (m :: * -&gt; *) a.
MonadDebug m =&gt;
VerboseKey -&gt; Int -&gt; TCMT IO Doc -&gt; m a -&gt; m a
</span><a href="Agda.TypeChecking.Monad.Debug.html#traceSDoc"><span class="hs-identifier hs-var">traceSDoc</span></a></span><span> </span><span class="annot"><span class="annottext">VerboseKey
</span><span class="hs-string">&quot;tc.match&quot;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">50</span></span><span>
</span><span id="line-174"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TCMT IO Doc] -&gt; TCMT IO Doc
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Foldable t) =&gt;
t (m Doc) -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#vcat"><span class="hs-identifier hs-var">vcat</span></a></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
</span><span class="hs-string">&quot;matchCopatterns&quot;</span></span><span>
</span><span id="line-175"></span><span>          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Functor m =&gt; Int -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#nest"><span class="hs-identifier hs-var">nest</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="annot"><span class="annottext">(TCMT IO Doc -&gt; TCMT IO Doc) -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
</span><span class="hs-string">&quot;ps =&quot;</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; m Doc -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[TCMT IO Doc] -&gt; TCMT IO Doc
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Foldable t) =&gt;
t (m Doc) -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#fsep"><span class="hs-identifier hs-var">fsep</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TCMT IO Doc -&gt; [TCMT IO Doc] -&gt; [TCMT IO Doc]
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Semigroup (m Doc), Foldable t) =&gt;
m Doc -&gt; t (m Doc) -&gt; [m Doc]
</span><a href="Agda.TypeChecking.Pretty.html#punctuate"><span class="hs-identifier hs-var">punctuate</span></a></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#comma"><span class="hs-identifier hs-var">comma</span></a></span><span> </span><span class="annot"><span class="annottext">([TCMT IO Doc] -&gt; [TCMT IO Doc]) -&gt; [TCMT IO Doc] -&gt; [TCMT IO Doc]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(NamedArg DeBruijnPattern -&gt; TCMT IO Doc)
-&gt; [NamedArg DeBruijnPattern] -&gt; [TCMT IO Doc]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DeBruijnPattern -&gt; TCMT IO Doc
forall a (m :: * -&gt; *). (PrettyTCM a, MonadPretty m) =&gt; a -&gt; m Doc
forall (m :: * -&gt; *). MonadPretty m =&gt; DeBruijnPattern -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#prettyTCM"><span class="hs-identifier hs-var">prettyTCM</span></a></span><span> </span><span class="annot"><span class="annottext">(DeBruijnPattern -&gt; TCMT IO Doc)
-&gt; (NamedArg DeBruijnPattern -&gt; DeBruijnPattern)
-&gt; NamedArg DeBruijnPattern
-&gt; TCMT IO Doc
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">NamedArg DeBruijnPattern -&gt; DeBruijnPattern
forall a. NamedArg a -&gt; a
</span><a href="Agda.Syntax.Common.html#namedArg"><span class="hs-identifier hs-var">namedArg</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621682056221"><span class="hs-identifier hs-var">ps</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-176"></span><span>          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Functor m =&gt; Int -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#nest"><span class="hs-identifier hs-var">nest</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="annot"><span class="annottext">(TCMT IO Doc -&gt; TCMT IO Doc) -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
</span><span class="hs-string">&quot;vs =&quot;</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; m Doc -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[TCMT IO Doc] -&gt; TCMT IO Doc
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Foldable t) =&gt;
t (m Doc) -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#fsep"><span class="hs-identifier hs-var">fsep</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TCMT IO Doc -&gt; [TCMT IO Doc] -&gt; [TCMT IO Doc]
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Semigroup (m Doc), Foldable t) =&gt;
m Doc -&gt; t (m Doc) -&gt; [m Doc]
</span><a href="Agda.TypeChecking.Pretty.html#punctuate"><span class="hs-identifier hs-var">punctuate</span></a></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#comma"><span class="hs-identifier hs-var">comma</span></a></span><span> </span><span class="annot"><span class="annottext">([TCMT IO Doc] -&gt; [TCMT IO Doc]) -&gt; [TCMT IO Doc] -&gt; [TCMT IO Doc]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Elim -&gt; TCMT IO Doc) -&gt; [Elim] -&gt; [TCMT IO Doc]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Elim -&gt; TCMT IO Doc
forall a (m :: * -&gt; *). (PrettyTCM a, MonadPretty m) =&gt; a -&gt; m Doc
forall (m :: * -&gt; *). MonadPretty m =&gt; Elim -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#prettyTCM"><span class="hs-identifier hs-var">prettyTCM</span></a></span><span> </span><span class="annot"><span class="annottext">[Elim]
</span><a href="#local-6989586621682056222"><span class="hs-identifier hs-var">vs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-177"></span><span>          </span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(m (Match Term, [Elim]) -&gt; m (Match Term, [Elim]))
-&gt; m (Match Term, [Elim]) -&gt; m (Match Term, [Elim])
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-178"></span><span>  </span><span class="hs-comment">-- Buggy, see issue 1124:</span><span>
</span><span id="line-179"></span><span>  </span><span class="hs-comment">-- first mconcat . unzip &lt;$&gt; zipWithM' (matchCopattern . namedArg) ps vs</span><span>
</span><span id="line-180"></span><span>  </span><span class="annot"><span class="annottext">(NamedArg DeBruijnPattern -&gt; Elim -&gt; m (Match Term, Elim))
-&gt; [NamedArg DeBruijnPattern] -&gt; [Elim] -&gt; m (Match Term, [Elim])
forall (m :: * -&gt; *) p v.
(IsProjP p, MonadMatch m) =&gt;
(p -&gt; v -&gt; m (Match Term, v)) -&gt; [p] -&gt; [v] -&gt; m (Match Term, [v])
</span><a href="Agda.TypeChecking.Patterns.Match.html#foldMatch"><span class="hs-identifier hs-var">foldMatch</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DeBruijnPattern -&gt; Elim -&gt; m (Match Term, Elim)
forall (m :: * -&gt; *).
MonadMatch m =&gt;
DeBruijnPattern -&gt; Elim -&gt; m (Match Term, Elim)
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchCopattern"><span class="hs-identifier hs-var">matchCopattern</span></a></span><span> </span><span class="annot"><span class="annottext">(DeBruijnPattern -&gt; Elim -&gt; m (Match Term, Elim))
-&gt; (NamedArg DeBruijnPattern -&gt; DeBruijnPattern)
-&gt; NamedArg DeBruijnPattern
-&gt; Elim
-&gt; m (Match Term, Elim)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">NamedArg DeBruijnPattern -&gt; DeBruijnPattern
forall a. NamedArg a -&gt; a
</span><a href="Agda.Syntax.Common.html#namedArg"><span class="hs-identifier hs-var">namedArg</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621682056221"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="annot"><span class="annottext">[Elim]
</span><a href="#local-6989586621682056222"><span class="hs-identifier hs-var">vs</span></a></span><span>
</span><span id="line-181"></span><span>
</span><span id="line-182"></span><span class="annot"><span class="hs-comment">-- | Match a single copattern.</span></span><span>
</span><span id="line-183"></span><span id="local-6989586621682055813"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchCopattern"><span class="hs-identifier hs-type">matchCopattern</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#MonadMatch"><span class="hs-identifier hs-type">MonadMatch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055813"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-184"></span><span>               </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-identifier hs-type">DeBruijnPattern</span></a></span><span>
</span><span id="line-185"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Elim"><span class="hs-identifier hs-type">Elim</span></a></span><span>
</span><span id="line-186"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682055813"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Elim"><span class="hs-identifier hs-type">Elim</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-187"></span><span id="matchCopattern"><span class="annot"><span class="annottext">matchCopattern :: forall (m :: * -&gt; *).
MonadMatch m =&gt;
DeBruijnPattern -&gt; Elim -&gt; m (Match Term, Elim)
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchCopattern"><span class="hs-identifier hs-var hs-var">matchCopattern</span></a></span></span><span> </span><span id="local-6989586621682056265"><span class="annot"><span class="annottext">pat :: DeBruijnPattern
</span><a href="#local-6989586621682056265"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><a href="Agda.Syntax.Internal.html#ProjP"><span class="hs-identifier hs-type">ProjP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span id="local-6989586621682056267"><span class="annot"><span class="annottext">elim :: Elim
</span><a href="#local-6989586621682056267"><span class="hs-identifier hs-var">elim</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.Elim.html#Proj"><span class="hs-identifier hs-type">Proj</span></a></span><span> </span><span class="annot"><span class="annottext">ProjOrigin
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682056268"><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621682056268"><span class="hs-identifier hs-var">q</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-188"></span><span>  </span><span id="local-6989586621682056269"><span class="annot"><a href="#local-6989586621682056269"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern -&gt; m DeBruijnPattern
forall a (m :: * -&gt; *).
(NormaliseProjP a, HasConstInfo m) =&gt;
a -&gt; m a
forall (m :: * -&gt; *).
HasConstInfo m =&gt;
DeBruijnPattern -&gt; m DeBruijnPattern
</span><a href="Agda.TypeChecking.Records.html#normaliseProjP"><span class="hs-identifier hs-var">normaliseProjP</span></a></span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621682056265"><span class="hs-identifier hs-var">pat</span></a></span><span> </span><span class="annot"><span class="annottext">m DeBruijnPattern -&gt; (DeBruijnPattern -&gt; QName) -&gt; m QName
forall (f :: * -&gt; *) a b. Functor f =&gt; f a -&gt; (a -&gt; b) -&gt; f b
</span><span class="hs-operator hs-var">&lt;&amp;&gt;</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-189"></span><span>         </span><span class="annot"><a href="Agda.Syntax.Internal.html#ProjP"><span class="hs-identifier hs-type">ProjP</span></a></span><span> </span><span class="annot"><span class="annottext">ProjOrigin
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682056271"><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621682056271"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621682056271"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-190"></span><span>         </span><span class="annot"><span class="annottext">DeBruijnPattern
</span><span class="hs-identifier">_</span></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">QName
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>
</span><span id="line-191"></span><span>  </span><span id="local-6989586621682056272"><span class="annot"><a href="#local-6989586621682056272"><span class="hs-identifier hs-var">q</span></a></span></span><span>       </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Signature.html#getOriginalProjection"><span class="hs-identifier hs-type">getOriginalProjection</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682056268"><span class="hs-identifier hs-type">q</span></a></span><span>
</span><span id="line-192"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><a href="#local-6989586621682056269"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">==</span></span><span> </span><span class="annot"><a href="#local-6989586621682056272"><span class="hs-identifier hs-type">q</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-type">Yes</span></a></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Base.html#YesSimplification"><span class="hs-identifier hs-type">YesSimplification</span></a></span><span> </span><span class="annot"><a href="Agda.Utils.Null.html#empty"><span class="hs-identifier hs-type">empty</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621682056267"><span class="hs-identifier hs-type">elim</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-193"></span><span>                     </span><span class="hs-keyword">else</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-type">No</span></a></span><span class="hs-special">,</span><span>                          </span><span class="annot"><a href="#local-6989586621682056267"><span class="hs-identifier hs-type">elim</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-194"></span><span class="hs-comment">-- The following two cases are not impossible, see #2964</span><span>
</span><span id="line-195"></span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchCopattern"><span class="hs-identifier hs-var">matchCopattern</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#ProjP"><span class="hs-identifier hs-type">ProjP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span id="local-6989586621682056275"><span class="annot"><span class="annottext">elim :: Elim
</span><a href="#local-6989586621682056275"><span class="hs-identifier hs-var">elim</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><a href="Agda.Syntax.Internal.Elim.html#Apply"><span class="hs-identifier hs-type">Apply</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Match Term, Elim) -&gt; m (Match Term, Elim)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Match Term
forall a. Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span> </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Elim
</span><a href="#local-6989586621682056275"><span class="hs-identifier hs-var">elim</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-196"></span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchCopattern"><span class="hs-identifier hs-var">matchCopattern</span></a></span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern
</span><span class="hs-identifier">_</span></span><span>       </span><span id="local-6989586621682056276"><span class="annot"><span class="annottext">elim :: Elim
</span><a href="#local-6989586621682056276"><span class="hs-identifier hs-var">elim</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><a href="Agda.Syntax.Internal.Elim.html#Proj"><span class="hs-identifier hs-type">Proj</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Match Term, Elim) -&gt; m (Match Term, Elim)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Match Term
forall a. Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span> </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Elim
</span><a href="#local-6989586621682056276"><span class="hs-identifier hs-var">elim</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-197"></span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchCopattern"><span class="hs-identifier hs-var">matchCopattern</span></a></span><span> </span><span id="local-6989586621682056277"><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621682056277"><span class="hs-identifier hs-var">p</span></a></span></span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.Elim.html#Apply"><span class="hs-identifier hs-type">Apply</span></a></span><span> </span><span id="local-6989586621682056278"><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056278"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Arg Term -&gt; Elim) -&gt; (Match Term, Arg Term) -&gt; (Match Term, Elim)
forall b c a. (b -&gt; c) -&gt; (a, b) -&gt; (a, c)
forall (p :: * -&gt; * -&gt; *) b c a.
Bifunctor p =&gt;
(b -&gt; c) -&gt; p a b -&gt; p a c
</span><span class="hs-identifier hs-var">second</span></span><span> </span><span class="annot"><span class="annottext">Arg Term -&gt; Elim
forall a. Arg a -&gt; Elim' a
</span><a href="Agda.Syntax.Internal.Elim.html#Apply"><span class="hs-identifier hs-var">Apply</span></a></span><span> </span><span class="annot"><span class="annottext">((Match Term, Arg Term) -&gt; (Match Term, Elim))
-&gt; m (Match Term, Arg Term) -&gt; m (Match Term, Elim)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term)
forall (m :: * -&gt; *).
MonadMatch m =&gt;
DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term)
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPattern"><span class="hs-identifier hs-var">matchPattern</span></a></span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621682056277"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056278"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-198"></span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchCopattern"><span class="hs-identifier hs-var">matchCopattern</span></a></span><span> </span><span id="local-6989586621682056282"><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621682056282"><span class="hs-identifier hs-var">p</span></a></span></span><span>       </span><span id="local-6989586621682056283"><span class="annot"><span class="annottext">e :: Elim
</span><a href="#local-6989586621682056283"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.Elim.html#IApply"><span class="hs-identifier hs-type">IApply</span></a></span><span> </span><span id="local-6989586621682056284"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056284"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621682056285"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056285"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span id="local-6989586621682056286"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056286"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Arg Term -&gt; Elim) -&gt; (Match Term, Arg Term) -&gt; (Match Term, Elim)
forall b c a. (b -&gt; c) -&gt; (a, b) -&gt; (a, c)
forall (p :: * -&gt; * -&gt; *) b c a.
Bifunctor p =&gt;
(b -&gt; c) -&gt; p a b -&gt; p a c
</span><span class="hs-identifier hs-var">second</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Elim -&gt; Arg Term -&gt; Elim
</span><a href="Agda.TypeChecking.Patterns.Match.html#mergeElim"><span class="hs-identifier hs-var">mergeElim</span></a></span><span> </span><span class="annot"><span class="annottext">Elim
</span><a href="#local-6989586621682056283"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">((Match Term, Arg Term) -&gt; (Match Term, Elim))
-&gt; m (Match Term, Arg Term) -&gt; m (Match Term, Elim)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term)
forall (m :: * -&gt; *).
MonadMatch m =&gt;
DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term)
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPattern"><span class="hs-identifier hs-var">matchPattern</span></a></span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621682056282"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Term -&gt; Arg Term
forall a. a -&gt; Arg a
</span><a href="Agda.Syntax.Common.html#defaultArg"><span class="hs-identifier hs-var">defaultArg</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056286"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-199"></span><span>
</span><span id="line-200"></span><span class="hs-pragma">{-# SPECIALIZE</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchPatterns"><span class="hs-pragma hs-type">matchPatterns</span></a></span><span> </span><span class="hs-pragma">::</span><span> </span><span class="hs-pragma">[</span><span class="annot"><a href="Agda.Syntax.Common.html#NamedArg"><span class="hs-pragma hs-type">NamedArg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-pragma hs-type">DeBruijnPattern</span></a></span><span class="hs-pragma">]</span><span> </span><span class="hs-pragma">-&gt;</span><span> </span><span class="hs-pragma">[</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-pragma hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-pragma hs-type">Term</span></a></span><span class="hs-pragma">]</span><span> </span><span class="hs-pragma">-&gt;</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Base.html#TCM"><span class="hs-pragma hs-type">TCM</span></a></span><span> </span><span class="hs-pragma">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-pragma hs-type">Match</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-pragma hs-type">Term</span></a></span><span class="hs-pragma">,</span><span> </span><span class="hs-pragma">[</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-pragma hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-pragma hs-type">Term</span></a></span><span class="hs-pragma">]</span><span class="hs-pragma">)</span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-201"></span><span id="local-6989586621682055836"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchPatterns"><span class="hs-identifier hs-type">matchPatterns</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#MonadMatch"><span class="hs-identifier hs-type">MonadMatch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055836"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-202"></span><span>              </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Common.html#NamedArg"><span class="hs-identifier hs-type">NamedArg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-identifier hs-type">DeBruijnPattern</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-203"></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-204"></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682055836"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span></span><span>
</span><span id="line-205"></span><span id="matchPatterns"><span class="annot"><span class="annottext">matchPatterns :: forall (m :: * -&gt; *).
MonadMatch m =&gt;
[NamedArg DeBruijnPattern]
-&gt; [Arg Term] -&gt; m (Match Term, [Arg Term])
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPatterns"><span class="hs-identifier hs-var hs-var">matchPatterns</span></a></span></span><span> </span><span id="local-6989586621682056373"><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621682056373"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span id="local-6989586621682056374"><span class="annot"><span class="annottext">[Arg Term]
</span><a href="#local-6989586621682056374"><span class="hs-identifier hs-var">vs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-206"></span><span>  </span><span class="annot"><span class="annottext">VerboseKey -&gt; Int -&gt; TCMT IO Doc -&gt; m ()
forall (m :: * -&gt; *).
MonadDebug m =&gt;
VerboseKey -&gt; Int -&gt; TCMT IO Doc -&gt; m ()
</span><a href="Agda.TypeChecking.Monad.Debug.html#reportSDoc"><span class="hs-identifier hs-var">reportSDoc</span></a></span><span> </span><span class="annot"><span class="annottext">VerboseKey
</span><span class="hs-string">&quot;tc.match&quot;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">20</span></span><span> </span><span class="annot"><span class="annottext">(TCMT IO Doc -&gt; m ()) -&gt; TCMT IO Doc -&gt; m ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-207"></span><span>     </span><span class="annot"><span class="annottext">[TCMT IO Doc] -&gt; TCMT IO Doc
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Foldable t) =&gt;
t (m Doc) -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#vcat"><span class="hs-identifier hs-var">vcat</span></a></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
</span><span class="hs-string">&quot;matchPatterns&quot;</span></span><span>
</span><span id="line-208"></span><span>          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Functor m =&gt; Int -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#nest"><span class="hs-identifier hs-var">nest</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="annot"><span class="annottext">(TCMT IO Doc -&gt; TCMT IO Doc) -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
</span><span class="hs-string">&quot;ps =&quot;</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; m Doc -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern] -&gt; TCMT IO Doc
forall (m :: * -&gt; *).
MonadPretty m =&gt;
[NamedArg DeBruijnPattern] -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#prettyTCMPatternList"><span class="hs-identifier hs-var">prettyTCMPatternList</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621682056373"><span class="hs-identifier hs-var">ps</span></a></span><span>
</span><span id="line-209"></span><span>          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Functor m =&gt; Int -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#nest"><span class="hs-identifier hs-var">nest</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="annot"><span class="annottext">(TCMT IO Doc -&gt; TCMT IO Doc) -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
</span><span class="hs-string">&quot;vs =&quot;</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; m Doc -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[TCMT IO Doc] -&gt; TCMT IO Doc
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Foldable t) =&gt;
t (m Doc) -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#fsep"><span class="hs-identifier hs-var">fsep</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TCMT IO Doc -&gt; [TCMT IO Doc] -&gt; [TCMT IO Doc]
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Semigroup (m Doc), Foldable t) =&gt;
m Doc -&gt; t (m Doc) -&gt; [m Doc]
</span><a href="Agda.TypeChecking.Pretty.html#punctuate"><span class="hs-identifier hs-var">punctuate</span></a></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#comma"><span class="hs-identifier hs-var">comma</span></a></span><span> </span><span class="annot"><span class="annottext">([TCMT IO Doc] -&gt; [TCMT IO Doc]) -&gt; [TCMT IO Doc] -&gt; [TCMT IO Doc]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Arg Term -&gt; TCMT IO Doc) -&gt; [Arg Term] -&gt; [TCMT IO Doc]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Arg Term -&gt; TCMT IO Doc
forall a (m :: * -&gt; *). (PrettyTCM a, MonadPretty m) =&gt; a -&gt; m Doc
forall (m :: * -&gt; *). MonadPretty m =&gt; Arg Term -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#prettyTCM"><span class="hs-identifier hs-var">prettyTCM</span></a></span><span> </span><span class="annot"><span class="annottext">[Arg Term]
</span><a href="#local-6989586621682056374"><span class="hs-identifier hs-var">vs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-210"></span><span>          </span><span class="hs-special">]</span><span>
</span><span id="line-211"></span><span>
</span><span id="line-212"></span><span>  </span><span class="annot"><span class="annottext">VerboseKey
-&gt; Int
-&gt; TCMT IO Doc
-&gt; m (Match Term, [Arg Term])
-&gt; m (Match Term, [Arg Term])
forall (m :: * -&gt; *) a.
MonadDebug m =&gt;
VerboseKey -&gt; Int -&gt; TCMT IO Doc -&gt; m a -&gt; m a
</span><a href="Agda.TypeChecking.Monad.Debug.html#traceSDoc"><span class="hs-identifier hs-var">traceSDoc</span></a></span><span> </span><span class="annot"><span class="annottext">VerboseKey
</span><span class="hs-string">&quot;tc.match&quot;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">50</span></span><span>
</span><span id="line-213"></span><span>    </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TCMT IO Doc] -&gt; TCMT IO Doc
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Foldable t) =&gt;
t (m Doc) -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#vcat"><span class="hs-identifier hs-var">vcat</span></a></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
</span><span class="hs-string">&quot;matchPatterns&quot;</span></span><span>
</span><span id="line-214"></span><span>          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Functor m =&gt; Int -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#nest"><span class="hs-identifier hs-var">nest</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="annot"><span class="annottext">(TCMT IO Doc -&gt; TCMT IO Doc) -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
</span><span class="hs-string">&quot;ps =&quot;</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; m Doc -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[TCMT IO Doc] -&gt; TCMT IO Doc
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Foldable t) =&gt;
t (m Doc) -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#fsep"><span class="hs-identifier hs-var">fsep</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TCMT IO Doc -&gt; [TCMT IO Doc] -&gt; [TCMT IO Doc]
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Semigroup (m Doc), Foldable t) =&gt;
m Doc -&gt; t (m Doc) -&gt; [m Doc]
</span><a href="Agda.TypeChecking.Pretty.html#punctuate"><span class="hs-identifier hs-var">punctuate</span></a></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#comma"><span class="hs-identifier hs-var">comma</span></a></span><span> </span><span class="annot"><span class="annottext">([TCMT IO Doc] -&gt; [TCMT IO Doc]) -&gt; [TCMT IO Doc] -&gt; [TCMT IO Doc]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(NamedArg DeBruijnPattern -&gt; TCMT IO Doc)
-&gt; [NamedArg DeBruijnPattern] -&gt; [TCMT IO Doc]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">VerboseKey -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; VerboseKey -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">(VerboseKey -&gt; TCMT IO Doc)
-&gt; (NamedArg DeBruijnPattern -&gt; VerboseKey)
-&gt; NamedArg DeBruijnPattern
-&gt; TCMT IO Doc
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">NamedArg DeBruijnPattern -&gt; VerboseKey
forall a. Show a =&gt; a -&gt; VerboseKey
</span><span class="hs-identifier hs-var">show</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621682056373"><span class="hs-identifier hs-var">ps</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-215"></span><span>          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Functor m =&gt; Int -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#nest"><span class="hs-identifier hs-var">nest</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="annot"><span class="annottext">(TCMT IO Doc -&gt; TCMT IO Doc) -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
</span><span class="hs-string">&quot;vs =&quot;</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; m Doc -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[TCMT IO Doc] -&gt; TCMT IO Doc
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Foldable t) =&gt;
t (m Doc) -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#fsep"><span class="hs-identifier hs-var">fsep</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TCMT IO Doc -&gt; [TCMT IO Doc] -&gt; [TCMT IO Doc]
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Semigroup (m Doc), Foldable t) =&gt;
m Doc -&gt; t (m Doc) -&gt; [m Doc]
</span><a href="Agda.TypeChecking.Pretty.html#punctuate"><span class="hs-identifier hs-var">punctuate</span></a></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#comma"><span class="hs-identifier hs-var">comma</span></a></span><span> </span><span class="annot"><span class="annottext">([TCMT IO Doc] -&gt; [TCMT IO Doc]) -&gt; [TCMT IO Doc] -&gt; [TCMT IO Doc]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Arg Term -&gt; TCMT IO Doc) -&gt; [Arg Term] -&gt; [TCMT IO Doc]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Arg Term -&gt; TCMT IO Doc
forall a (m :: * -&gt; *). (PrettyTCM a, MonadPretty m) =&gt; a -&gt; m Doc
forall (m :: * -&gt; *). MonadPretty m =&gt; Arg Term -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#prettyTCM"><span class="hs-identifier hs-var">prettyTCM</span></a></span><span> </span><span class="annot"><span class="annottext">[Arg Term]
</span><a href="#local-6989586621682056374"><span class="hs-identifier hs-var">vs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-216"></span><span>          </span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(m (Match Term, [Arg Term]) -&gt; m (Match Term, [Arg Term]))
-&gt; m (Match Term, [Arg Term]) -&gt; m (Match Term, [Arg Term])
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-217"></span><span>  </span><span class="hs-comment">-- Buggy, see issue 1124:</span><span>
</span><span id="line-218"></span><span>  </span><span class="hs-comment">-- (ms,vs) &lt;- unzip &lt;$&gt; zipWithM' (matchPattern . namedArg) ps vs</span><span>
</span><span id="line-219"></span><span>  </span><span class="hs-comment">-- return (mconcat ms, vs)</span><span>
</span><span id="line-220"></span><span>  </span><span class="annot"><span class="annottext">(NamedArg DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term))
-&gt; [NamedArg DeBruijnPattern]
-&gt; [Arg Term]
-&gt; m (Match Term, [Arg Term])
forall (m :: * -&gt; *) p v.
(IsProjP p, MonadMatch m) =&gt;
(p -&gt; v -&gt; m (Match Term, v)) -&gt; [p] -&gt; [v] -&gt; m (Match Term, [v])
</span><a href="Agda.TypeChecking.Patterns.Match.html#foldMatch"><span class="hs-identifier hs-var">foldMatch</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term)
forall (m :: * -&gt; *).
MonadMatch m =&gt;
DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term)
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPattern"><span class="hs-identifier hs-var">matchPattern</span></a></span><span> </span><span class="annot"><span class="annottext">(DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term))
-&gt; (NamedArg DeBruijnPattern -&gt; DeBruijnPattern)
-&gt; NamedArg DeBruijnPattern
-&gt; Arg Term
-&gt; m (Match Term, Arg Term)
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">NamedArg DeBruijnPattern -&gt; DeBruijnPattern
forall a. NamedArg a -&gt; a
</span><a href="Agda.Syntax.Common.html#namedArg"><span class="hs-identifier hs-var">namedArg</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621682056373"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="annot"><span class="annottext">[Arg Term]
</span><a href="#local-6989586621682056374"><span class="hs-identifier hs-var">vs</span></a></span><span>
</span><span id="line-221"></span><span>
</span><span id="line-222"></span><span class="annot"><span class="hs-comment">-- | Match a single pattern.</span></span><span>
</span><span id="line-223"></span><span id="local-6989586621682055834"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchPattern"><span class="hs-identifier hs-type">matchPattern</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#MonadMatch"><span class="hs-identifier hs-type">MonadMatch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055834"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-224"></span><span>             </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-identifier hs-type">DeBruijnPattern</span></a></span><span>
</span><span id="line-225"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span>
</span><span id="line-226"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682055834"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-227"></span><span id="matchPattern"><span class="annot"><span class="annottext">matchPattern :: forall (m :: * -&gt; *).
MonadMatch m =&gt;
DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term)
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPattern"><span class="hs-identifier hs-var hs-var">matchPattern</span></a></span></span><span> </span><span id="local-6989586621682056470"><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621682056470"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621682056471"><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056471"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621682056470"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056471"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-228"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#ProjP"><span class="hs-identifier hs-type">ProjP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match Term, Arg Term)
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>
</span><span id="line-229"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#IApplyP"><span class="hs-identifier hs-type">IApplyP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682056473"><span class="annot"><span class="annottext">DBPatVar
</span><a href="#local-6989586621682056473"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-special">,</span><span> </span><span id="local-6989586621682056474"><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056474"><span class="hs-identifier hs-var">arg</span></a></span></span><span> </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, Arg Term) -&gt; m (Match Term, Arg Term)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Simplification -&gt; IntMap (Arg Term) -&gt; Match Term
forall a. Simplification -&gt; IntMap (Arg a) -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-var">Yes</span></a></span><span> </span><span class="annot"><span class="annottext">Simplification
</span><a href="Agda.TypeChecking.Monad.Base.html#NoSimplification"><span class="hs-identifier hs-var">NoSimplification</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg Term)
</span><a href="#local-6989586621682056476"><span class="hs-identifier hs-var">entry</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056474"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-230"></span><span>    </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621682056476"><span class="annot"><span class="annottext">entry :: IntMap (Arg Term)
</span><a href="#local-6989586621682056476"><span class="hs-identifier hs-var hs-var">entry</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Int, Arg Term) -&gt; IntMap (Arg Term)
forall el coll. Singleton el coll =&gt; el -&gt; coll
</span><a href="Agda.Utils.Singleton.html#singleton"><span class="hs-identifier hs-var">singleton</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DBPatVar -&gt; Int
</span><a href="Agda.Syntax.Internal.html#dbPatVarIndex"><span class="hs-identifier hs-var">dbPatVarIndex</span></a></span><span> </span><span class="annot"><span class="annottext">DBPatVar
</span><a href="#local-6989586621682056473"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056474"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-231"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#VarP"><span class="hs-identifier hs-type">VarP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682056480"><span class="annot"><span class="annottext">DBPatVar
</span><a href="#local-6989586621682056480"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-special">,</span><span> </span><span id="local-6989586621682056481"><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056481"><span class="hs-identifier hs-var">arg</span></a></span></span><span>          </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, Arg Term) -&gt; m (Match Term, Arg Term)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Simplification -&gt; IntMap (Arg Term) -&gt; Match Term
forall a. Simplification -&gt; IntMap (Arg a) -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-var">Yes</span></a></span><span> </span><span class="annot"><span class="annottext">Simplification
</span><a href="Agda.TypeChecking.Monad.Base.html#NoSimplification"><span class="hs-identifier hs-var">NoSimplification</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg Term)
</span><a href="#local-6989586621682056482"><span class="hs-identifier hs-var">entry</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056481"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-232"></span><span>    </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621682056482"><span class="annot"><span class="annottext">entry :: IntMap (Arg Term)
</span><a href="#local-6989586621682056482"><span class="hs-identifier hs-var hs-var">entry</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Int, Arg Term) -&gt; IntMap (Arg Term)
forall el coll. Singleton el coll =&gt; el -&gt; coll
</span><a href="Agda.Utils.Singleton.html#singleton"><span class="hs-identifier hs-var">singleton</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DBPatVar -&gt; Int
</span><a href="Agda.Syntax.Internal.html#dbPatVarIndex"><span class="hs-identifier hs-var">dbPatVarIndex</span></a></span><span> </span><span class="annot"><span class="annottext">DBPatVar
</span><a href="#local-6989586621682056480"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056481"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-233"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#DotP"><span class="hs-identifier hs-type">DotP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">,</span><span> </span><span id="local-6989586621682056484"><span class="annot"><span class="annottext">arg :: Arg Term
</span><a href="#local-6989586621682056484"><span class="hs-identifier hs-var">arg</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><span class="annottext">ArgInfo
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682056486"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056486"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, Arg Term) -&gt; m (Match Term, Arg Term)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Simplification -&gt; IntMap (Arg Term) -&gt; Match Term
forall a. Simplification -&gt; IntMap (Arg a) -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-var">Yes</span></a></span><span> </span><span class="annot"><span class="annottext">Simplification
</span><a href="Agda.TypeChecking.Monad.Base.html#NoSimplification"><span class="hs-identifier hs-var">NoSimplification</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg Term)
forall a. Null a =&gt; a
</span><a href="Agda.Utils.Null.html#empty"><span class="hs-identifier hs-var">empty</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056484"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-234"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#LitP"><span class="hs-identifier hs-type">LitP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682056488"><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621682056488"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-special">,</span><span> </span><span id="local-6989586621682056489"><span class="annot"><span class="annottext">arg :: Arg Term
</span><a href="#local-6989586621682056489"><span class="hs-identifier hs-var">arg</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><span class="annottext">ArgInfo
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682056490"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056490"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-235"></span><span>    </span><span id="local-6989586621682056491"><span class="annot"><a href="#local-6989586621682056491"><span class="hs-identifier hs-var">w</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Term -&gt; m (Blocked Term)
forall a (m :: * -&gt; *).
(Reduce a, MonadReduce m) =&gt;
a -&gt; m (Blocked a)
</span><a href="Agda.TypeChecking.Reduce.html#reduceB"><span class="hs-identifier hs-var">reduceB</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056490"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-236"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621682056493"><span class="annot"><a href="#local-6989586621682056493"><span class="hs-identifier hs-var hs-var">arg'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056489"><span class="hs-identifier hs-var">arg</span></a></span><span> </span><span class="annot"><span class="annottext">Arg Term -&gt; Term -&gt; Arg Term
forall (f :: * -&gt; *) a b. Functor f =&gt; f a -&gt; b -&gt; f b
</span><span class="hs-operator hs-var">$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Blocked Term -&gt; Term
forall t a. Blocked' t a -&gt; a
</span><a href="Agda.Syntax.Internal.Blockers.html#ignoreBlocking"><span class="hs-identifier hs-var">ignoreBlocking</span></a></span><span> </span><span class="annot"><span class="annottext">Blocked Term
</span><a href="#local-6989586621682056491"><span class="hs-identifier hs-var">w</span></a></span><span>
</span><span id="line-237"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="#local-6989586621682056491"><span class="hs-identifier hs-type">w</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-238"></span><span>      </span><span class="annot"><a href="Agda.Syntax.Internal.Blockers.html#NotBlocked"><span class="hs-identifier hs-type">NotBlocked</span></a></span><span> </span><span class="annot"><span class="annottext">NotBlocked' Term
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Lit"><span class="hs-identifier hs-type">Lit</span></a></span><span> </span><span id="local-6989586621682056497"><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621682056497"><span class="hs-identifier hs-var">l'</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-239"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621682056488"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">Literal -&gt; Literal -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621682056497"><span class="hs-identifier hs-var">l'</span></a></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, Arg Term) -&gt; m (Match Term, Arg Term)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Simplification -&gt; IntMap (Arg Term) -&gt; Match Term
forall a. Simplification -&gt; IntMap (Arg a) -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-var">Yes</span></a></span><span> </span><span class="annot"><span class="annottext">Simplification
</span><a href="Agda.TypeChecking.Monad.Base.html#YesSimplification"><span class="hs-identifier hs-var">YesSimplification</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg Term)
forall a. Null a =&gt; a
</span><a href="Agda.Utils.Null.html#empty"><span class="hs-identifier hs-var">empty</span></a></span><span> </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056493"><span class="hs-identifier hs-var">arg'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-240"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, Arg Term) -&gt; m (Match Term, Arg Term)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Match Term
forall a. Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span>                          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056493"><span class="hs-identifier hs-var">arg'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-241"></span><span>      </span><span class="annot"><a href="Agda.Syntax.Internal.Blockers.html#Blocked"><span class="hs-identifier hs-type">Blocked</span></a></span><span> </span><span id="local-6989586621682056499"><span class="annot"><span class="annottext">Blocker
</span><a href="#local-6989586621682056499"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, Arg Term) -&gt; m (Match Term, Arg Term)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">OnlyLazy -&gt; Blocked () -&gt; Match Term
forall a. OnlyLazy -&gt; Blocked () -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-var">DontKnow</span></a></span><span> </span><span class="annot"><span class="annottext">OnlyLazy
</span><a href="Agda.TypeChecking.Patterns.Match.html#NonLazy"><span class="hs-identifier hs-var">NonLazy</span></a></span><span> </span><span class="annot"><span class="annottext">(Blocked () -&gt; Match Term) -&gt; Blocked () -&gt; Match Term
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Blocker -&gt; () -&gt; Blocked ()
forall t a. Blocker -&gt; a -&gt; Blocked' t a
</span><a href="Agda.Syntax.Internal.Blockers.html#Blocked"><span class="hs-identifier hs-var">Blocked</span></a></span><span> </span><span class="annot"><span class="annottext">Blocker
</span><a href="#local-6989586621682056499"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>     </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056493"><span class="hs-identifier hs-var">arg'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-242"></span><span>      </span><span class="annot"><a href="Agda.Syntax.Internal.Blockers.html#NotBlocked"><span class="hs-identifier hs-type">NotBlocked</span></a></span><span> </span><span id="local-6989586621682056500"><span class="annot"><span class="annottext">NotBlocked' Term
</span><a href="#local-6989586621682056500"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span id="local-6989586621682056501"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056501"><span class="hs-identifier hs-var">t</span></a></span></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, Arg Term) -&gt; m (Match Term, Arg Term)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">OnlyLazy -&gt; Blocked () -&gt; Match Term
forall a. OnlyLazy -&gt; Blocked () -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-var">DontKnow</span></a></span><span> </span><span class="annot"><span class="annottext">OnlyLazy
</span><a href="Agda.TypeChecking.Patterns.Match.html#NonLazy"><span class="hs-identifier hs-var">NonLazy</span></a></span><span> </span><span class="annot"><span class="annottext">(Blocked () -&gt; Match Term) -&gt; Blocked () -&gt; Match Term
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">NotBlocked' Term -&gt; () -&gt; Blocked ()
forall t a. NotBlocked' t -&gt; a -&gt; Blocked' t a
</span><a href="Agda.Syntax.Internal.Blockers.html#NotBlocked"><span class="hs-identifier hs-var">NotBlocked</span></a></span><span> </span><span class="annot"><span class="annottext">NotBlocked' Term
</span><a href="#local-6989586621682056502"><span class="hs-identifier hs-var">r'</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056493"><span class="hs-identifier hs-var">arg'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-243"></span><span>        </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621682056502"><span class="annot"><span class="annottext">r' :: NotBlocked' Term
</span><a href="#local-6989586621682056502"><span class="hs-identifier hs-var hs-var">r'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Elim -&gt; NotBlocked' Term -&gt; NotBlocked' Term
forall t. Elim' t -&gt; NotBlocked' t -&gt; NotBlocked' t
</span><a href="Agda.Syntax.Internal.Blockers.html#stuckOn"><span class="hs-identifier hs-var">stuckOn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Arg Term -&gt; Elim
forall a. Arg a -&gt; Elim' a
</span><a href="Agda.Syntax.Internal.Elim.html#Apply"><span class="hs-identifier hs-var">Apply</span></a></span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056493"><span class="hs-identifier hs-var">arg'</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">NotBlocked' Term
</span><a href="#local-6989586621682056500"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-244"></span><span>
</span><span id="line-245"></span><span>  </span><span class="hs-comment">-- Case constructor pattern.</span><span>
</span><span id="line-246"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#ConP"><span class="hs-identifier hs-type">ConP</span></a></span><span> </span><span id="local-6989586621682056505"><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682056505"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621682056506"><span class="annot"><span class="annottext">ConPatternInfo
</span><a href="#local-6989586621682056506"><span class="hs-identifier hs-var">cpi</span></a></span></span><span> </span><span id="local-6989586621682056507"><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621682056507"><span class="hs-identifier hs-var">ps</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span id="local-6989586621682056508"><span class="annot"><span class="annottext">ArgInfo
</span><a href="#local-6989586621682056508"><span class="hs-identifier hs-var">info</span></a></span></span><span> </span><span id="local-6989586621682056509"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056509"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-247"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621682056510"><span class="annot"><span class="annottext">lazy :: OnlyLazy
</span><a href="#local-6989586621682056510"><span class="hs-identifier hs-var hs-var">lazy</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">ConPatternInfo -&gt; Bool
</span><a href="Agda.Syntax.Internal.html#conPLazy"><span class="hs-identifier hs-var">conPLazy</span></a></span><span> </span><span class="annot"><span class="annottext">ConPatternInfo
</span><a href="#local-6989586621682056506"><span class="hs-identifier hs-var">cpi</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">OnlyLazy
</span><a href="Agda.TypeChecking.Patterns.Match.html#OnlyLazy"><span class="hs-identifier hs-var">OnlyLazy</span></a></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">OnlyLazy
</span><a href="Agda.TypeChecking.Patterns.Match.html#NonLazy"><span class="hs-identifier hs-var">NonLazy</span></a></span><span>
</span><span id="line-248"></span><span>    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ConPatternInfo -&gt; Bool
</span><a href="Agda.Syntax.Internal.html#conPRecord"><span class="hs-identifier hs-var">conPRecord</span></a></span><span> </span><span class="annot"><span class="annottext">ConPatternInfo
</span><a href="#local-6989586621682056506"><span class="hs-identifier hs-var">cpi</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">ConHead
-&gt; OnlyLazy
-&gt; [NamedArg DeBruijnPattern]
-&gt; Arg Term
-&gt; m (Match Term, Arg Term)
forall (m :: * -&gt; *).
MonadMatch m =&gt;
ConHead
-&gt; OnlyLazy
-&gt; [NamedArg DeBruijnPattern]
-&gt; Arg Term
-&gt; m (Match Term, Arg Term)
</span><a href="#local-6989586621682056514"><span class="hs-identifier hs-var">fallback</span></a></span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682056505"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">OnlyLazy
</span><a href="#local-6989586621682056510"><span class="hs-identifier hs-var">lazy</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621682056507"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ArgInfo -&gt; Term -&gt; Arg Term
forall e. ArgInfo -&gt; e -&gt; Arg e
</span><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-var">Arg</span></a></span><span> </span><span class="annot"><span class="annottext">ArgInfo
</span><a href="#local-6989586621682056508"><span class="hs-identifier hs-var">info</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056509"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">else</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-249"></span><span>    </span><span class="annot"><span class="annottext">QName -&gt; m (Maybe (QName, RecordData))
forall (m :: * -&gt; *).
(HasCallStack, HasConstInfo m) =&gt;
QName -&gt; m (Maybe (QName, RecordData))
</span><a href="Agda.TypeChecking.Records.html#isEtaRecordConstructor"><span class="hs-identifier hs-var">isEtaRecordConstructor</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ConHead -&gt; QName
</span><a href="Agda.Syntax.Internal.html#conName"><span class="hs-identifier hs-var">conName</span></a></span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682056505"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m (Maybe (QName, RecordData))
-&gt; (Maybe (QName, RecordData) -&gt; m (Match Term, Arg Term))
-&gt; m (Match Term, Arg Term)
forall a b. m a -&gt; (a -&gt; m b) -&gt; m b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-250"></span><span>      </span><span class="annot"><span class="annottext">Maybe (QName, RecordData)
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ConHead
-&gt; OnlyLazy
-&gt; [NamedArg DeBruijnPattern]
-&gt; Arg Term
-&gt; m (Match Term, Arg Term)
forall (m :: * -&gt; *).
MonadMatch m =&gt;
ConHead
-&gt; OnlyLazy
-&gt; [NamedArg DeBruijnPattern]
-&gt; Arg Term
-&gt; m (Match Term, Arg Term)
</span><a href="#local-6989586621682056514"><span class="hs-identifier hs-var">fallback</span></a></span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682056505"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">OnlyLazy
</span><a href="#local-6989586621682056510"><span class="hs-identifier hs-var">lazy</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621682056507"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ArgInfo -&gt; Term -&gt; Arg Term
forall e. ArgInfo -&gt; e -&gt; Arg e
</span><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-var">Arg</span></a></span><span> </span><span class="annot"><span class="annottext">ArgInfo
</span><a href="#local-6989586621682056508"><span class="hs-identifier hs-var">info</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056509"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-251"></span><span>      </span><span class="hs-comment">-- Case: Eta record constructor.</span><span>
</span><span id="line-252"></span><span>      </span><span class="hs-comment">-- This case is necessary if we want to use the clauses before</span><span>
</span><span id="line-253"></span><span>      </span><span class="hs-comment">-- record pattern translation (e.g., in type-checking definitions by copatterns).</span><span>
</span><span id="line-254"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621682056517"><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621682056517"><span class="hs-identifier hs-var">_r</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621682056518"><span class="annot"><span class="annottext">RecordData
</span><a href="#local-6989586621682056518"><span class="hs-identifier hs-var">def</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-255"></span><span>        </span><span class="annot"><span class="annottext">VerboseKey -&gt; Int -&gt; TCMT IO Doc -&gt; m ()
forall (m :: * -&gt; *).
MonadDebug m =&gt;
VerboseKey -&gt; Int -&gt; TCMT IO Doc -&gt; m ()
</span><a href="Agda.TypeChecking.Monad.Debug.html#reportSDoc"><span class="hs-identifier hs-var">reportSDoc</span></a></span><span> </span><span class="annot"><span class="annottext">VerboseKey
</span><span class="hs-string">&quot;tc.match&quot;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">50</span></span><span> </span><span class="annot"><span class="annottext">(TCMT IO Doc -&gt; m ()) -&gt; TCMT IO Doc -&gt; m ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TCMT IO Doc] -&gt; TCMT IO Doc
forall (m :: * -&gt; *) (t :: * -&gt; *).
(Applicative m, Foldable t) =&gt;
t (m Doc) -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#vcat"><span class="hs-identifier hs-var">vcat</span></a></span><span>
</span><span id="line-256"></span><span>          </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
</span><span class="hs-string">&quot;matchPattern: eta record&quot;</span></span><span>
</span><span id="line-257"></span><span>          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Functor m =&gt; Int -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#nest"><span class="hs-identifier hs-var">nest</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="annot"><span class="annottext">(TCMT IO Doc -&gt; TCMT IO Doc) -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
</span><span class="hs-string">&quot;c  = &quot;</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; m Doc -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">ConHead -&gt; TCMT IO Doc
forall a (m :: * -&gt; *). (PrettyTCM a, MonadPretty m) =&gt; a -&gt; m Doc
forall (m :: * -&gt; *). MonadPretty m =&gt; ConHead -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#prettyTCM"><span class="hs-identifier hs-var">prettyTCM</span></a></span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682056505"><span class="hs-identifier hs-var">c</span></a></span><span>
</span><span id="line-258"></span><span>          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Functor m =&gt; Int -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#nest"><span class="hs-identifier hs-var">nest</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="annot"><span class="annottext">(TCMT IO Doc -&gt; TCMT IO Doc) -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
</span><span class="hs-string">&quot;ps = &quot;</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; m Doc -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern] -&gt; TCMT IO Doc
forall (m :: * -&gt; *).
MonadPretty m =&gt;
[NamedArg DeBruijnPattern] -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#prettyTCMPatternList"><span class="hs-identifier hs-var">prettyTCMPatternList</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621682056507"><span class="hs-identifier hs-var">ps</span></a></span><span>
</span><span id="line-259"></span><span>          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Int -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Functor m =&gt; Int -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#nest"><span class="hs-identifier hs-var">nest</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="annot"><span class="annottext">(TCMT IO Doc -&gt; TCMT IO Doc) -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc
</span><span class="hs-string">&quot;v  = &quot;</span></span><span> </span><span class="annot"><span class="annottext">TCMT IO Doc -&gt; TCMT IO Doc -&gt; TCMT IO Doc
forall (m :: * -&gt; *). Applicative m =&gt; m Doc -&gt; m Doc -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Term -&gt; TCMT IO Doc
forall a (m :: * -&gt; *). (PrettyTCM a, MonadPretty m) =&gt; a -&gt; m Doc
forall (m :: * -&gt; *). MonadPretty m =&gt; Term -&gt; m Doc
</span><a href="Agda.TypeChecking.Pretty.html#prettyTCM"><span class="hs-identifier hs-var">prettyTCM</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056509"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-260"></span><span>          </span><span class="hs-special">]</span><span>
</span><span id="line-261"></span><span>        </span><span class="hs-comment">-- Issue #7266: in case we are brazenly matching potentially ill-typed arguments,</span><span>
</span><span id="line-262"></span><span>        </span><span class="hs-comment">-- `v` might be an application of a *different* constructor.</span><span>
</span><span id="line-263"></span><span>        </span><span class="hs-comment">-- In that case we certainly have no match.</span><span>
</span><span id="line-264"></span><span>        </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056509"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-265"></span><span>          </span><span class="annot"><a href="Agda.Syntax.Internal.html#Con"><span class="hs-identifier hs-type">Con</span></a></span><span> </span><span id="local-6989586621682056520"><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682056520"><span class="hs-identifier hs-var">c'</span></a></span></span><span> </span><span class="annot"><span class="annottext">ConInfo
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[Elim]
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682056505"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">ConHead -&gt; ConHead -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">/=</span></span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682056520"><span class="hs-identifier hs-var">c'</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, Arg Term) -&gt; m (Match Term, Arg Term)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Match Term
forall a. Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056471"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-266"></span><span>          </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-267"></span><span>            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621682056522"><span class="annot"><span class="annottext">fs :: [Arg QName]
</span><a href="#local-6989586621682056522"><span class="hs-identifier hs-var hs-var hs-var">fs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Dom QName -&gt; Arg QName) -&gt; [Dom QName] -&gt; [Arg QName]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Dom QName -&gt; Arg QName
forall t a. Dom' t a -&gt; Arg a
</span><a href="Agda.Syntax.Internal.html#argFromDom"><span class="hs-identifier hs-var">argFromDom</span></a></span><span> </span><span class="annot"><span class="annottext">([Dom QName] -&gt; [Arg QName]) -&gt; [Dom QName] -&gt; [Arg QName]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">RecordData -&gt; [Dom QName]
</span><a href="Agda.TypeChecking.Monad.Base.html#_recFields"><span class="hs-identifier hs-var">_recFields</span></a></span><span> </span><span class="annot"><span class="annottext">RecordData
</span><a href="#local-6989586621682056518"><span class="hs-identifier hs-var">def</span></a></span><span>
</span><span id="line-268"></span><span>            </span><span class="annot"><span class="annottext">Bool -&gt; m () -&gt; m ()
forall (f :: * -&gt; *). Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</span><span class="hs-identifier hs-var">unless</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Arg QName] -&gt; Int
forall a. Sized a =&gt; a -&gt; Int
</span><a href="Agda.Utils.Size.html#size"><span class="hs-identifier hs-var">size</span></a></span><span> </span><span class="annot"><span class="annottext">[Arg QName]
</span><a href="#local-6989586621682056522"><span class="hs-identifier hs-var">fs</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern] -&gt; Int
forall a. Sized a =&gt; a -&gt; Int
</span><a href="Agda.Utils.Size.html#size"><span class="hs-identifier hs-var">size</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621682056507"><span class="hs-identifier hs-var">ps</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m ()
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>
</span><span id="line-269"></span><span>            </span><span class="annot"><span class="annottext">([Arg Term] -&gt; Arg Term)
-&gt; (Match Term, [Arg Term]) -&gt; (Match Term, Arg Term)
forall b c a. (b -&gt; c) -&gt; (a, b) -&gt; (a, c)
forall (p :: * -&gt; * -&gt; *) b c a.
Bifunctor p =&gt;
(b -&gt; c) -&gt; p a b -&gt; p a c
</span><span class="hs-identifier hs-var">second</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ArgInfo -&gt; Term -&gt; Arg Term
forall e. ArgInfo -&gt; e -&gt; Arg e
</span><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-var">Arg</span></a></span><span> </span><span class="annot"><span class="annottext">ArgInfo
</span><a href="#local-6989586621682056508"><span class="hs-identifier hs-var">info</span></a></span><span> </span><span class="annot"><span class="annottext">(Term -&gt; Arg Term)
-&gt; ([Arg Term] -&gt; Term) -&gt; [Arg Term] -&gt; Arg Term
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">ConHead -&gt; ConInfo -&gt; [Elim] -&gt; Term
</span><a href="Agda.Syntax.Internal.html#Con"><span class="hs-identifier hs-var">Con</span></a></span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682056505"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ConPatternInfo -&gt; ConInfo
</span><a href="Agda.Syntax.Internal.html#fromConPatternInfo"><span class="hs-identifier hs-var">fromConPatternInfo</span></a></span><span> </span><span class="annot"><span class="annottext">ConPatternInfo
</span><a href="#local-6989586621682056506"><span class="hs-identifier hs-var">cpi</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">([Elim] -&gt; Term) -&gt; ([Arg Term] -&gt; [Elim]) -&gt; [Arg Term] -&gt; Term
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Arg Term -&gt; Elim) -&gt; [Arg Term] -&gt; [Elim]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Arg Term -&gt; Elim
forall a. Arg a -&gt; Elim' a
</span><a href="Agda.Syntax.Internal.Elim.html#Apply"><span class="hs-identifier hs-var">Apply</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">((Match Term, [Arg Term]) -&gt; (Match Term, Arg Term))
-&gt; m (Match Term, [Arg Term]) -&gt; m (Match Term, Arg Term)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-270"></span><span>              </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
-&gt; [Arg Term] -&gt; m (Match Term, [Arg Term])
forall (m :: * -&gt; *).
MonadMatch m =&gt;
[NamedArg DeBruijnPattern]
-&gt; [Arg Term] -&gt; m (Match Term, [Arg Term])
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPatterns"><span class="hs-identifier hs-var">matchPatterns</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621682056507"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="annot"><span class="annottext">([Arg Term] -&gt; m (Match Term, [Arg Term]))
-&gt; [Arg Term] -&gt; m (Match Term, [Arg Term])
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Arg QName] -&gt; (Arg QName -&gt; Arg Term) -&gt; [Arg Term]
forall (f :: * -&gt; *) a b. Functor f =&gt; f a -&gt; (a -&gt; b) -&gt; f b
</span><a href="Agda.Utils.Functor.html#for"><span class="hs-identifier hs-var">for</span></a></span><span> </span><span class="annot"><span class="annottext">[Arg QName]
</span><a href="#local-6989586621682056522"><span class="hs-identifier hs-var">fs</span></a></span><span> </span><span class="annot"><span class="annottext">((Arg QName -&gt; Arg Term) -&gt; [Arg Term])
-&gt; (Arg QName -&gt; Arg Term) -&gt; [Arg Term]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span id="local-6989586621682056528"><span class="annot"><span class="annottext">ArgInfo
</span><a href="#local-6989586621682056528"><span class="hs-identifier hs-var">ai</span></a></span></span><span> </span><span id="local-6989586621682056529"><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621682056529"><span class="hs-identifier hs-var">f</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ArgInfo -&gt; Term -&gt; Arg Term
forall e. ArgInfo -&gt; e -&gt; Arg e
</span><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-var">Arg</span></a></span><span> </span><span class="annot"><span class="annottext">ArgInfo
</span><a href="#local-6989586621682056528"><span class="hs-identifier hs-var">ai</span></a></span><span> </span><span class="annot"><span class="annottext">(Term -&gt; Arg Term) -&gt; Term -&gt; Arg Term
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056509"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">Term -&gt; [Elim] -&gt; Term
forall t. Apply t =&gt; t -&gt; [Elim] -&gt; t
</span><a href="Agda.TypeChecking.Substitute.Class.html#applyE"><span class="hs-operator hs-var">`applyE`</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">ProjOrigin -&gt; QName -&gt; Elim
forall a. ProjOrigin -&gt; QName -&gt; Elim' a
</span><a href="Agda.Syntax.Internal.Elim.html#Proj"><span class="hs-identifier hs-var">Proj</span></a></span><span> </span><span class="annot"><span class="annottext">ProjOrigin
</span><a href="Agda.Syntax.Common.html#ProjSystem"><span class="hs-identifier hs-var">ProjSystem</span></a></span><span> </span><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621682056529"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-271"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#DefP"><span class="hs-identifier hs-type">DefP</span></a></span><span> </span><span id="local-6989586621682056533"><span class="annot"><span class="annottext">PatternInfo
</span><a href="#local-6989586621682056533"><span class="hs-identifier hs-var">o</span></a></span></span><span> </span><span id="local-6989586621682056534"><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621682056534"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span id="local-6989586621682056535"><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621682056535"><span class="hs-identifier hs-var">ps</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621682056536"><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056536"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-272"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621682056537"><span class="annot"><span class="annottext">f :: Term -&gt; Maybe ([Elim] -&gt; Term, [Elim])
</span><a href="#local-6989586621682056537"><span class="hs-identifier hs-var hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Def"><span class="hs-identifier hs-type">Def</span></a></span><span> </span><span id="local-6989586621682056539"><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621682056539"><span class="hs-identifier hs-var">q'</span></a></span></span><span> </span><span id="local-6989586621682056540"><span class="annot"><span class="annottext">[Elim]
</span><a href="#local-6989586621682056540"><span class="hs-identifier hs-var">vs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621682056534"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="annot"><span class="annottext">QName -&gt; QName -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621682056539"><span class="hs-identifier hs-var">q'</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([Elim] -&gt; Term, [Elim]) -&gt; Maybe ([Elim] -&gt; Term, [Elim])
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">QName -&gt; [Elim] -&gt; Term
</span><a href="Agda.Syntax.Internal.html#Def"><span class="hs-identifier hs-var">Def</span></a></span><span> </span><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621682056534"><span class="hs-identifier hs-var">q</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[Elim]
</span><a href="#local-6989586621682056540"><span class="hs-identifier hs-var">vs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-273"></span><span>        </span><span class="annot"><a href="#local-6989586621682056537"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span>                     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe ([Elim] -&gt; Term, [Elim])
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-274"></span><span>    </span><span class="annot"><span class="annottext">(Term -&gt; Maybe ([Elim] -&gt; Term, [Elim]))
-&gt; OnlyLazy
-&gt; [NamedArg DeBruijnPattern]
-&gt; Arg Term
-&gt; m (Match Term, Arg Term)
forall (m :: * -&gt; *).
MonadMatch m =&gt;
(Term -&gt; Maybe ([Elim] -&gt; Term, [Elim]))
-&gt; OnlyLazy
-&gt; [NamedArg DeBruijnPattern]
-&gt; Arg Term
-&gt; m (Match Term, Arg Term)
</span><a href="#local-6989586621682056541"><span class="hs-identifier hs-var">fallback'</span></a></span><span> </span><span class="annot"><span class="annottext">Term -&gt; Maybe ([Elim] -&gt; Term, [Elim])
</span><a href="#local-6989586621682056537"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">OnlyLazy
</span><a href="Agda.TypeChecking.Patterns.Match.html#NonLazy"><span class="hs-identifier hs-var">NonLazy</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621682056535"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056536"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-275"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-276"></span><span>    </span><span class="hs-comment">-- Default: not an eta record constructor.</span><span>
</span><span id="line-277"></span><span>  </span><span id="local-6989586621682055878"><span class="annot"><a href="#local-6989586621682056514"><span class="hs-identifier hs-type">fallback</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#MonadMatch"><span class="hs-identifier hs-type">MonadMatch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055878"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-278"></span><span>           </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#ConHead"><span class="hs-identifier hs-type">ConHead</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#OnlyLazy"><span class="hs-identifier hs-type">OnlyLazy</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Common.html#NamedArg"><span class="hs-identifier hs-type">NamedArg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-identifier hs-type">DeBruijnPattern</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682055878"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-279"></span><span>  </span><span id="local-6989586621682056514"><span class="annot"><span class="annottext">fallback :: forall (m :: * -&gt; *).
MonadMatch m =&gt;
ConHead
-&gt; OnlyLazy
-&gt; [NamedArg DeBruijnPattern]
-&gt; Arg Term
-&gt; m (Match Term, Arg Term)
</span><a href="#local-6989586621682056514"><span class="hs-identifier hs-var hs-var">fallback</span></a></span></span><span> </span><span id="local-6989586621682056545"><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682056545"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621682056546"><span class="annot"><span class="annottext">OnlyLazy
</span><a href="#local-6989586621682056546"><span class="hs-identifier hs-var">lazy</span></a></span></span><span> </span><span id="local-6989586621682056547"><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621682056547"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span id="local-6989586621682056548"><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056548"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-280"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621682056549"><span class="annot"><span class="annottext">f :: Term -&gt; Maybe ([Elim] -&gt; Term, [Elim])
</span><a href="#local-6989586621682056549"><span class="hs-identifier hs-var hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Con"><span class="hs-identifier hs-type">Con</span></a></span><span> </span><span id="local-6989586621682056550"><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682056550"><span class="hs-identifier hs-var">c'</span></a></span></span><span> </span><span id="local-6989586621682056551"><span class="annot"><span class="annottext">ConInfo
</span><a href="#local-6989586621682056551"><span class="hs-identifier hs-var">ci'</span></a></span></span><span> </span><span id="local-6989586621682056552"><span class="annot"><span class="annottext">[Elim]
</span><a href="#local-6989586621682056552"><span class="hs-identifier hs-var">vs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682056545"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">ConHead -&gt; ConHead -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682056550"><span class="hs-identifier hs-var">c'</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([Elim] -&gt; Term, [Elim]) -&gt; Maybe ([Elim] -&gt; Term, [Elim])
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ConHead -&gt; ConInfo -&gt; [Elim] -&gt; Term
</span><a href="Agda.Syntax.Internal.html#Con"><span class="hs-identifier hs-var">Con</span></a></span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682056550"><span class="hs-identifier hs-var">c'</span></a></span><span> </span><span class="annot"><span class="annottext">ConInfo
</span><a href="#local-6989586621682056551"><span class="hs-identifier hs-var">ci'</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">[Elim]
</span><a href="#local-6989586621682056552"><span class="hs-identifier hs-var">vs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-281"></span><span>        </span><span class="annot"><a href="#local-6989586621682056549"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span>                         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe ([Elim] -&gt; Term, [Elim])
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-282"></span><span>    </span><span class="annot"><span class="annottext">(Term -&gt; Maybe ([Elim] -&gt; Term, [Elim]))
-&gt; OnlyLazy
-&gt; [NamedArg DeBruijnPattern]
-&gt; Arg Term
-&gt; m (Match Term, Arg Term)
forall (m :: * -&gt; *).
MonadMatch m =&gt;
(Term -&gt; Maybe ([Elim] -&gt; Term, [Elim]))
-&gt; OnlyLazy
-&gt; [NamedArg DeBruijnPattern]
-&gt; Arg Term
-&gt; m (Match Term, Arg Term)
</span><a href="#local-6989586621682056541"><span class="hs-identifier hs-var">fallback'</span></a></span><span> </span><span class="annot"><span class="annottext">Term -&gt; Maybe ([Elim] -&gt; Term, [Elim])
</span><a href="#local-6989586621682056549"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">OnlyLazy
</span><a href="#local-6989586621682056546"><span class="hs-identifier hs-var">lazy</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621682056547"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056548"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-283"></span><span>
</span><span id="line-284"></span><span>  </span><span class="hs-comment">-- Regardless of blocking, constructors and a properly applied @hcomp@</span><span>
</span><span id="line-285"></span><span>  </span><span class="hs-comment">-- can be matched on.</span><span>
</span><span id="line-286"></span><span>  </span><span id="local-6989586621682055894"><span class="annot"><a href="#local-6989586621682056553"><span class="hs-identifier hs-type">isMatchable'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Builtin.html#HasBuiltins"><span class="hs-identifier hs-type">HasBuiltins</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055894"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682055894"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Blocked"><span class="hs-identifier hs-type">Blocked</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-287"></span><span>  </span><span id="local-6989586621682056553"><span class="annot"><span class="annottext">isMatchable' :: forall (m :: * -&gt; *).
HasBuiltins m =&gt;
m (Blocked Term -&gt; Maybe Term)
</span><a href="#local-6989586621682056553"><span class="hs-identifier hs-var hs-var">isMatchable'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-288"></span><span>    </span><span id="local-6989586621682056563"><span class="annot"><a href="#local-6989586621682056563"><span class="hs-identifier hs-var">mhcomp</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">PrimitiveId -&gt; m (Maybe QName)
forall (m :: * -&gt; *) a.
(HasBuiltins m, IsBuiltin a) =&gt;
a -&gt; m (Maybe QName)
</span><a href="Agda.TypeChecking.Monad.Builtin.html#getName%27"><span class="hs-identifier hs-var">getName'</span></a></span><span> </span><span class="annot"><span class="annottext">PrimitiveId
</span><a href="Agda.Syntax.Builtin.html#builtinHComp"><span class="hs-identifier hs-var">builtinHComp</span></a></span><span>
</span><span id="line-289"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621682056564"><span class="annot"><span class="annottext">Blocked Term
</span><a href="#local-6989586621682056564"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-290"></span><span>      </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Blocked Term -&gt; Term
forall t a. Blocked' t a -&gt; a
</span><a href="Agda.Syntax.Internal.Blockers.html#ignoreBlocking"><span class="hs-identifier hs-var">ignoreBlocking</span></a></span><span> </span><span class="annot"><span class="annottext">Blocked Term
</span><a href="#local-6989586621682056564"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-291"></span><span>        </span><span id="local-6989586621682056565"><span class="annot"><span class="annottext">t :: Term
</span><a href="#local-6989586621682056565"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><a href="Agda.Syntax.Internal.html#Con"><span class="hs-identifier hs-type">Con</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Term -&gt; Maybe Term
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056565"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-292"></span><span>        </span><span id="local-6989586621682056566"><span class="annot"><span class="annottext">t :: Term
</span><a href="#local-6989586621682056566"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Def"><span class="hs-identifier hs-type">Def</span></a></span><span> </span><span id="local-6989586621682056567"><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621682056567"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="hs-special">[</span><span id="local-6989586621682056568"><span class="annot"><span class="annottext">Elim
</span><a href="#local-6989586621682056568"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621682056569"><span class="annot"><span class="annottext">Elim
</span><a href="#local-6989586621682056569"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621682056570"><span class="annot"><span class="annottext">Elim
</span><a href="#local-6989586621682056570"><span class="hs-identifier hs-var">phi</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621682056571"><span class="annot"><span class="annottext">Elim
</span><a href="#local-6989586621682056571"><span class="hs-identifier hs-var">u</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621682056572"><span class="annot"><span class="annottext">Elim
</span><a href="#local-6989586621682056572"><span class="hs-identifier hs-var">u0</span></a></span></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">QName -&gt; Maybe QName
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621682056567"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe QName -&gt; Maybe QName -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Maybe QName
</span><a href="#local-6989586621682056563"><span class="hs-identifier hs-var">mhcomp</span></a></span><span>
</span><span id="line-293"></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Term -&gt; Maybe Term
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056566"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-294"></span><span>        </span><span class="hs-comment">-- TODO this covers the transpIx functions, but it's a hack.</span><span>
</span><span id="line-295"></span><span>        </span><span id="local-6989586621682056573"><span class="annot"><span class="annottext">t :: Term
</span><a href="#local-6989586621682056573"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Def"><span class="hs-identifier hs-type">Def</span></a></span><span> </span><span id="local-6989586621682056574"><span class="annot"><span class="annottext">QName
</span><a href="#local-6989586621682056574"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Elim]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.Blockers.html#NotBlocked"><span class="hs-identifier hs-type">NotBlocked</span></a></span><span class="hs-special">{</span><span class="annot"><span class="annottext">blockingStatus :: forall t a. Blocked' t a -&gt; NotBlocked' t
</span><a href="Agda.Syntax.Internal.Blockers.html#blockingStatus"><span class="hs-identifier hs-var">blockingStatus</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.Blockers.html#MissingClauses"><span class="hs-identifier hs-type">MissingClauses</span></a></span><span> </span><span class="annot"><span class="annottext">QName
</span><span class="hs-identifier">_</span></span><span class="hs-special">}</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Blocked Term
</span><a href="#local-6989586621682056564"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Term -&gt; Maybe Term
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056573"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-296"></span><span>        </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe Term
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-297"></span><span>
</span><span id="line-298"></span><span>  </span><span class="hs-comment">-- DefP hcomp and ConP matching.</span><span>
</span><span id="line-299"></span><span>  </span><span id="local-6989586621682055892"><span class="annot"><a href="#local-6989586621682056541"><span class="hs-identifier hs-type">fallback'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#MonadMatch"><span class="hs-identifier hs-type">MonadMatch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055892"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-300"></span><span>            </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Elims"><span class="hs-identifier hs-type">Elims</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span> </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Elims"><span class="hs-identifier hs-type">Elims</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-301"></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#OnlyLazy"><span class="hs-identifier hs-type">OnlyLazy</span></a></span><span>
</span><span id="line-302"></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Common.html#NamedArg"><span class="hs-identifier hs-type">NamedArg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-identifier hs-type">DeBruijnPattern</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-303"></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span>
</span><span id="line-304"></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682055892"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Term"><span class="hs-identifier hs-type">Term</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-305"></span><span>  </span><span id="local-6989586621682056541"><span class="annot"><span class="annottext">fallback' :: forall (m :: * -&gt; *).
MonadMatch m =&gt;
(Term -&gt; Maybe ([Elim] -&gt; Term, [Elim]))
-&gt; OnlyLazy
-&gt; [NamedArg DeBruijnPattern]
-&gt; Arg Term
-&gt; m (Match Term, Arg Term)
</span><a href="#local-6989586621682056541"><span class="hs-identifier hs-var hs-var">fallback'</span></a></span></span><span> </span><span id="local-6989586621682056604"><span class="annot"><span class="annottext">Term -&gt; Maybe ([Elim] -&gt; Term, [Elim])
</span><a href="#local-6989586621682056604"><span class="hs-identifier hs-var">mtc</span></a></span></span><span> </span><span id="local-6989586621682056605"><span class="annot"><span class="annottext">OnlyLazy
</span><a href="#local-6989586621682056605"><span class="hs-identifier hs-var">lazy</span></a></span></span><span> </span><span id="local-6989586621682056606"><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621682056606"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span id="local-6989586621682056607"><span class="annot"><span class="annottext">ArgInfo
</span><a href="#local-6989586621682056607"><span class="hs-identifier hs-var">info</span></a></span></span><span> </span><span id="local-6989586621682056608"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056608"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-306"></span><span>        </span><span id="local-6989586621682056609"><span class="annot"><a href="#local-6989586621682056609"><span class="hs-identifier hs-var">isMatchable</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">m (Blocked Term -&gt; Maybe Term)
forall (m :: * -&gt; *).
HasBuiltins m =&gt;
m (Blocked Term -&gt; Maybe Term)
</span><a href="#local-6989586621682056553"><span class="hs-identifier hs-var">isMatchable'</span></a></span><span>
</span><span id="line-307"></span><span>
</span><span id="line-308"></span><span>        </span><span id="local-6989586621682056610"><span class="annot"><a href="#local-6989586621682056610"><span class="hs-identifier hs-var">w</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Reduce.html#reduceB"><span class="hs-identifier hs-type">reduceB</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682056608"><span class="hs-identifier hs-type">v</span></a></span><span>
</span><span id="line-309"></span><span>        </span><span class="hs-comment">-- Unfold delayed (corecursive) definitions one step. This is</span><span>
</span><span id="line-310"></span><span>        </span><span class="hs-comment">-- only necessary if c is a coinductive constructor, but</span><span>
</span><span id="line-311"></span><span>        </span><span class="hs-comment">-- it does not hurt to do it all the time.</span><span>
</span><span id="line-312"></span><span class="hs-comment">{-
        w &lt;- case w of
               NotBlocked r (Def f es) -&gt;   -- Andreas, 2014-06-12 TODO: r == ReallyNotBlocked sufficient?
                 unfoldDefinitionE True reduceB' (Def f []) f es
                   -- reduceB is used here because some constructors
                   -- are actually definitions which need to be
                   -- unfolded (due to open public).
               _ -&gt; return w
-}</span><span>
</span><span id="line-321"></span><span>        </span><span class="hs-comment">-- Jesper, 23-06-2016: Note that unfoldCorecursion may destroy</span><span>
</span><span id="line-322"></span><span>        </span><span class="hs-comment">-- constructor forms, so we only call constructorForm after.</span><span>
</span><span id="line-323"></span><span>        </span><span id="local-6989586621682056611"><span class="annot"><a href="#local-6989586621682056611"><span class="hs-identifier hs-var">w</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="hs-identifier hs-type">traverse</span></span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Builtin.html#constructorForm"><span class="hs-identifier hs-type">constructorForm</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">=&lt;&lt;</span></span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="#local-6989586621682056610"><span class="hs-identifier hs-type">w</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-324"></span><span>               </span><span class="annot"><a href="Agda.Syntax.Internal.Blockers.html#NotBlocked"><span class="hs-identifier hs-type">NotBlocked</span></a></span><span> </span><span id="local-6989586621682056615"><span class="annot"><span class="annottext">NotBlocked' Term
</span><a href="#local-6989586621682056615"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span id="local-6989586621682056616"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056616"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ReduceM (Blocked Term) -&gt; m (Blocked Term)
forall a. ReduceM a -&gt; m a
forall (m :: * -&gt; *) a. MonadReduce m =&gt; ReduceM a -&gt; m a
</span><a href="Agda.TypeChecking.Monad.Base.html#liftReduce"><span class="hs-identifier hs-var">liftReduce</span></a></span><span> </span><span class="annot"><span class="annottext">(ReduceM (Blocked Term) -&gt; m (Blocked Term))
-&gt; ReduceM (Blocked Term) -&gt; m (Blocked Term)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Term -&gt; ReduceM (Blocked Term)
</span><a href="Agda.TypeChecking.Reduce.html#unfoldCorecursion"><span class="hs-identifier hs-var">unfoldCorecursion</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056616"><span class="hs-identifier hs-var">u</span></a></span><span>  </span><span class="hs-comment">-- Andreas, 2014-06-12 TODO: r == ReallyNotBlocked sufficient?</span><span>
</span><span id="line-325"></span><span>               </span><span class="annot"><span class="annottext">Blocked Term
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Blocked Term -&gt; m (Blocked Term)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Blocked Term
</span><a href="#local-6989586621682056610"><span class="hs-identifier hs-var">w</span></a></span><span>
</span><span id="line-326"></span><span>        </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621682056619"><span class="annot"><a href="#local-6989586621682056619"><span class="hs-identifier hs-var hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Blocked Term -&gt; Term
forall t a. Blocked' t a -&gt; a
</span><a href="Agda.Syntax.Internal.Blockers.html#ignoreBlocking"><span class="hs-identifier hs-var">ignoreBlocking</span></a></span><span> </span><span class="annot"><span class="annottext">Blocked Term
</span><a href="#local-6989586621682056611"><span class="hs-identifier hs-var">w</span></a></span><span>
</span><span id="line-327"></span><span>            </span><span id="local-6989586621682056620"><span class="annot"><a href="#local-6989586621682056620"><span class="hs-identifier hs-var hs-var">arg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">ArgInfo -&gt; Term -&gt; Arg Term
forall e. ArgInfo -&gt; e -&gt; Arg e
</span><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-var">Arg</span></a></span><span> </span><span class="annot"><span class="annottext">ArgInfo
</span><a href="#local-6989586621682056607"><span class="hs-identifier hs-var">info</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056619"><span class="hs-identifier hs-var">v</span></a></span><span>  </span><span class="hs-comment">-- the reduced argument</span><span>
</span><span id="line-328"></span><span>
</span><span id="line-329"></span><span>        </span><span class="hs-keyword">case</span><span> </span><span class="annot"><a href="#local-6989586621682056611"><span class="hs-identifier hs-type">w</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-330"></span><span>          </span><span id="local-6989586621682056621"><span class="annot"><span class="annottext">Blocked Term
</span><a href="#local-6989586621682056621"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621682056622"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056622"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Blocked Term -&gt; Maybe Term
</span><a href="#local-6989586621682056609"><span class="hs-identifier hs-var">isMatchable</span></a></span><span> </span><span class="annot"><span class="annottext">Blocked Term
</span><a href="#local-6989586621682056621"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-331"></span><span>            </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Term -&gt; Maybe ([Elim] -&gt; Term, [Elim])
</span><a href="#local-6989586621682056604"><span class="hs-identifier hs-var">mtc</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056622"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-332"></span><span>              </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621682056623"><span class="annot"><span class="annottext">[Elim] -&gt; Term
</span><a href="#local-6989586621682056623"><span class="hs-identifier hs-var">bld</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621682056624"><span class="annot"><span class="annottext">[Elim]
</span><a href="#local-6989586621682056624"><span class="hs-identifier hs-var">vs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-333"></span><span>                </span><span class="hs-special">(</span><span id="local-6989586621682056625"><span class="annot"><a href="#local-6989586621682056625"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621682056626"><span class="annot"><a href="#local-6989586621682056626"><span class="hs-identifier hs-var">vs1</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
-&gt; [Arg Term] -&gt; m (Match Term, [Arg Term])
forall (m :: * -&gt; *).
MonadMatch m =&gt;
[NamedArg DeBruijnPattern]
-&gt; [Arg Term] -&gt; m (Match Term, [Arg Term])
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPatterns"><span class="hs-identifier hs-var">matchPatterns</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621682056606"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Arg Term] -&gt; Maybe [Arg Term] -&gt; [Arg Term]
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="annot"><span class="annottext">[Arg Term]
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span> </span><span class="annot"><span class="annottext">(Maybe [Arg Term] -&gt; [Arg Term]) -&gt; Maybe [Arg Term] -&gt; [Arg Term]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Elim] -&gt; Maybe [Arg Term]
forall a. [Elim' a] -&gt; Maybe [Arg a]
</span><a href="Agda.Syntax.Internal.Elim.html#allApplyElims"><span class="hs-identifier hs-var">allApplyElims</span></a></span><span> </span><span class="annot"><span class="annottext">[Elim]
</span><a href="#local-6989586621682056624"><span class="hs-identifier hs-var">vs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-334"></span><span>                </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#yesSimplification"><span class="hs-identifier hs-type">yesSimplification</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682056625"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682056607"><span class="hs-identifier hs-type">info</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><a href="#local-6989586621682056623"><span class="hs-identifier hs-type">bld</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#mergeElims"><span class="hs-identifier hs-type">mergeElims</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682056624"><span class="hs-identifier hs-type">vs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682056626"><span class="hs-identifier hs-type">vs1</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-335"></span><span>              </span><span class="annot"><span class="annottext">Maybe ([Elim] -&gt; Term, [Elim])
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-336"></span><span>                                    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, Arg Term) -&gt; m (Match Term, Arg Term)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Match Term
forall a. Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span>                          </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056620"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-337"></span><span>          </span><span class="annot"><a href="Agda.Syntax.Internal.Blockers.html#Blocked"><span class="hs-identifier hs-type">Blocked</span></a></span><span> </span><span id="local-6989586621682056629"><span class="annot"><span class="annottext">Blocker
</span><a href="#local-6989586621682056629"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, Arg Term) -&gt; m (Match Term, Arg Term)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">OnlyLazy -&gt; Blocked () -&gt; Match Term
forall a. OnlyLazy -&gt; Blocked () -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-var">DontKnow</span></a></span><span> </span><span class="annot"><span class="annottext">OnlyLazy
</span><a href="#local-6989586621682056605"><span class="hs-identifier hs-var">lazy</span></a></span><span> </span><span class="annot"><span class="annottext">(Blocked () -&gt; Match Term) -&gt; Blocked () -&gt; Match Term
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Blocker -&gt; () -&gt; Blocked ()
forall t a. Blocker -&gt; a -&gt; Blocked' t a
</span><a href="Agda.Syntax.Internal.Blockers.html#Blocked"><span class="hs-identifier hs-var">Blocked</span></a></span><span> </span><span class="annot"><span class="annottext">Blocker
</span><a href="#local-6989586621682056629"><span class="hs-identifier hs-var">b</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>     </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056620"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-338"></span><span>          </span><span class="annot"><a href="Agda.Syntax.Internal.Blockers.html#NotBlocked"><span class="hs-identifier hs-type">NotBlocked</span></a></span><span> </span><span id="local-6989586621682056630"><span class="annot"><span class="annottext">NotBlocked' Term
</span><a href="#local-6989586621682056630"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Match Term, Arg Term) -&gt; m (Match Term, Arg Term)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">OnlyLazy -&gt; Blocked () -&gt; Match Term
forall a. OnlyLazy -&gt; Blocked () -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#DontKnow"><span class="hs-identifier hs-var">DontKnow</span></a></span><span> </span><span class="annot"><span class="annottext">OnlyLazy
</span><a href="#local-6989586621682056605"><span class="hs-identifier hs-var">lazy</span></a></span><span> </span><span class="annot"><span class="annottext">(Blocked () -&gt; Match Term) -&gt; Blocked () -&gt; Match Term
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">NotBlocked' Term -&gt; () -&gt; Blocked ()
forall t a. NotBlocked' t -&gt; a -&gt; Blocked' t a
</span><a href="Agda.Syntax.Internal.Blockers.html#NotBlocked"><span class="hs-identifier hs-var">NotBlocked</span></a></span><span> </span><span class="annot"><span class="annottext">NotBlocked' Term
</span><a href="#local-6989586621682056631"><span class="hs-identifier hs-var">r'</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056620"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-339"></span><span>            </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621682056631"><span class="annot"><span class="annottext">r' :: NotBlocked' Term
</span><a href="#local-6989586621682056631"><span class="hs-identifier hs-var hs-var">r'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Elim -&gt; NotBlocked' Term -&gt; NotBlocked' Term
forall t. Elim' t -&gt; NotBlocked' t -&gt; NotBlocked' t
</span><a href="Agda.Syntax.Internal.Blockers.html#stuckOn"><span class="hs-identifier hs-var">stuckOn</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Arg Term -&gt; Elim
forall a. Arg a -&gt; Elim' a
</span><a href="Agda.Syntax.Internal.Elim.html#Apply"><span class="hs-identifier hs-var">Apply</span></a></span><span> </span><span class="annot"><span class="annottext">Arg Term
</span><a href="#local-6989586621682056620"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">NotBlocked' Term
</span><a href="#local-6989586621682056630"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-340"></span><span>
</span><span id="line-341"></span><span id="local-6989586621682055917"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#yesSimplification"><span class="hs-identifier hs-type">yesSimplification</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055917"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055917"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-342"></span><span id="yesSimplification"><span class="annot"><span class="annottext">yesSimplification :: forall a. Match a -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#yesSimplification"><span class="hs-identifier hs-var hs-var">yesSimplification</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-343"></span><span>  </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-type">Yes</span></a></span><span> </span><span class="annot"><span class="annottext">Simplification
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682056632"><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621682056632"><span class="hs-identifier hs-var">vs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Simplification -&gt; IntMap (Arg a) -&gt; Match a
forall a. Simplification -&gt; IntMap (Arg a) -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-var">Yes</span></a></span><span> </span><span class="annot"><span class="annottext">Simplification
</span><a href="Agda.TypeChecking.Monad.Base.html#YesSimplification"><span class="hs-identifier hs-var">YesSimplification</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg a)
</span><a href="#local-6989586621682056632"><span class="hs-identifier hs-var">vs</span></a></span><span>
</span><span id="line-344"></span><span>  </span><span id="local-6989586621682056633"><span class="annot"><span class="annottext">Match a
</span><a href="#local-6989586621682056633"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Match a
</span><a href="#local-6989586621682056633"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-345"></span><span>
</span><span id="line-346"></span><span class="hs-comment">-- Matching patterns against patterns -------------------------------------</span><span>
</span><span id="line-347"></span><span>
</span><span id="line-348"></span><span class="annot"><span class="hs-comment">-- | Match a single pattern.</span></span><span>
</span><span id="line-349"></span><span id="local-6989586621682055919"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchPatternP"><span class="hs-identifier hs-type">matchPatternP</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#MonadMatch"><span class="hs-identifier hs-type">MonadMatch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055919"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-350"></span><span>              </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-identifier hs-type">DeBruijnPattern</span></a></span><span>
</span><span id="line-351"></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-identifier hs-type">DeBruijnPattern</span></a></span><span>
</span><span id="line-352"></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682055919"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-identifier hs-type">DeBruijnPattern</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-353"></span><span id="matchPatternP"><span class="annot"><span class="annottext">matchPatternP :: forall (m :: * -&gt; *).
MonadMatch m =&gt;
DeBruijnPattern -&gt; Arg DeBruijnPattern -&gt; m (Match DeBruijnPattern)
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPatternP"><span class="hs-identifier hs-var hs-var">matchPatternP</span></a></span></span><span> </span><span id="local-6989586621682056660"><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621682056660"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span id="local-6989586621682056661"><span class="annot"><span class="annottext">ArgInfo
</span><a href="#local-6989586621682056661"><span class="hs-identifier hs-var">info</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#DotP"><span class="hs-identifier hs-type">DotP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682056662"><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056662"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-354"></span><span>  </span><span class="hs-special">(</span><span id="local-6989586621682056663"><span class="annot"><a href="#local-6989586621682056663"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621682056664"><span class="annot"><a href="#local-6989586621682056664"><span class="hs-identifier hs-var">arg</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term)
forall (m :: * -&gt; *).
MonadMatch m =&gt;
DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term)
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPattern"><span class="hs-identifier hs-var">matchPattern</span></a></span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621682056660"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ArgInfo -&gt; Term -&gt; Arg Term
forall e. ArgInfo -&gt; e -&gt; Arg e
</span><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-var">Arg</span></a></span><span> </span><span class="annot"><span class="annottext">ArgInfo
</span><a href="#local-6989586621682056661"><span class="hs-identifier hs-var">info</span></a></span><span> </span><span class="annot"><span class="annottext">Term
</span><a href="#local-6989586621682056662"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-355"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#DotP"><span class="hs-identifier hs-type">DotP</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#defaultPatternInfo"><span class="hs-identifier hs-type">defaultPatternInfo</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621682056663"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-356"></span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchPatternP"><span class="hs-identifier hs-var">matchPatternP</span></a></span><span> </span><span id="local-6989586621682056666"><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621682056666"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621682056667"><span class="annot"><span class="annottext">arg :: Arg DeBruijnPattern
</span><a href="#local-6989586621682056667"><span class="hs-identifier hs-var">arg</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span id="local-6989586621682056668"><span class="annot"><span class="annottext">ArgInfo
</span><a href="#local-6989586621682056668"><span class="hs-identifier hs-var">info</span></a></span></span><span> </span><span id="local-6989586621682056669"><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621682056669"><span class="hs-identifier hs-var">q</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-357"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621682056670"><span class="annot"><span class="annottext">varMatch :: DBPatVar -&gt; m (Match DeBruijnPattern)
</span><a href="#local-6989586621682056670"><span class="hs-identifier hs-var hs-var">varMatch</span></a></span></span><span> </span><span id="local-6989586621682056671"><span class="annot"><span class="annottext">DBPatVar
</span><a href="#local-6989586621682056671"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Match DeBruijnPattern -&gt; m (Match DeBruijnPattern)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Match DeBruijnPattern -&gt; m (Match DeBruijnPattern))
-&gt; Match DeBruijnPattern -&gt; m (Match DeBruijnPattern)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Simplification
-&gt; IntMap (Arg DeBruijnPattern) -&gt; Match DeBruijnPattern
forall a. Simplification -&gt; IntMap (Arg a) -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-var">Yes</span></a></span><span> </span><span class="annot"><span class="annottext">Simplification
</span><a href="Agda.TypeChecking.Monad.Base.html#NoSimplification"><span class="hs-identifier hs-var">NoSimplification</span></a></span><span> </span><span class="annot"><span class="annottext">(IntMap (Arg DeBruijnPattern) -&gt; Match DeBruijnPattern)
-&gt; IntMap (Arg DeBruijnPattern) -&gt; Match DeBruijnPattern
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Int, Arg DeBruijnPattern) -&gt; IntMap (Arg DeBruijnPattern)
forall el coll. Singleton el coll =&gt; el -&gt; coll
</span><a href="Agda.Utils.Singleton.html#singleton"><span class="hs-identifier hs-var">singleton</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DBPatVar -&gt; Int
</span><a href="Agda.Syntax.Internal.html#dbPatVarIndex"><span class="hs-identifier hs-var">dbPatVarIndex</span></a></span><span> </span><span class="annot"><span class="annottext">DBPatVar
</span><a href="#local-6989586621682056671"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Arg DeBruijnPattern
</span><a href="#local-6989586621682056667"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-358"></span><span>      </span><span id="local-6989586621682056672"><span class="annot"><span class="annottext">termMatch :: m (Match DeBruijnPattern)
</span><a href="#local-6989586621682056672"><span class="hs-identifier hs-var hs-var">termMatch</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-359"></span><span>        </span><span class="hs-special">(</span><span id="local-6989586621682056673"><span class="annot"><a href="#local-6989586621682056673"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621682056674"><span class="annot"><a href="#local-6989586621682056674"><span class="hs-identifier hs-var">arg</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term)
forall (m :: * -&gt; *).
MonadMatch m =&gt;
DeBruijnPattern -&gt; Arg Term -&gt; m (Match Term, Arg Term)
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPattern"><span class="hs-identifier hs-var">matchPattern</span></a></span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621682056666"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(DeBruijnPattern -&gt; Term) -&gt; Arg DeBruijnPattern -&gt; Arg Term
forall a b. (a -&gt; b) -&gt; Arg a -&gt; Arg b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern -&gt; Term
</span><a href="Agda.Syntax.Internal.Pattern.html#patternToTerm"><span class="hs-identifier hs-var">patternToTerm</span></a></span><span> </span><span class="annot"><span class="annottext">Arg DeBruijnPattern
</span><a href="#local-6989586621682056667"><span class="hs-identifier hs-var">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-360"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#DotP"><span class="hs-identifier hs-type">DotP</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#defaultPatternInfo"><span class="hs-identifier hs-type">defaultPatternInfo</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621682056673"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-361"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621682056666"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-362"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#ProjP"><span class="hs-identifier hs-type">ProjP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match DeBruijnPattern)
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>
</span><span id="line-363"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#IApplyP"><span class="hs-identifier hs-type">IApplyP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682056676"><span class="annot"><span class="annottext">DBPatVar
</span><a href="#local-6989586621682056676"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">DBPatVar -&gt; m (Match DeBruijnPattern)
</span><a href="#local-6989586621682056670"><span class="hs-identifier hs-var">varMatch</span></a></span><span> </span><span class="annot"><span class="annottext">DBPatVar
</span><a href="#local-6989586621682056676"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-364"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#VarP"><span class="hs-identifier hs-type">VarP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682056677"><span class="annot"><span class="annottext">DBPatVar
</span><a href="#local-6989586621682056677"><span class="hs-identifier hs-var">x</span></a></span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">DBPatVar -&gt; m (Match DeBruijnPattern)
</span><a href="#local-6989586621682056670"><span class="hs-identifier hs-var">varMatch</span></a></span><span> </span><span class="annot"><span class="annottext">DBPatVar
</span><a href="#local-6989586621682056677"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-365"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#DotP"><span class="hs-identifier hs-type">DotP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Term
</span><span class="hs-identifier">_</span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Match DeBruijnPattern -&gt; m (Match DeBruijnPattern)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(Match DeBruijnPattern -&gt; m (Match DeBruijnPattern))
-&gt; Match DeBruijnPattern -&gt; m (Match DeBruijnPattern)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Simplification
-&gt; IntMap (Arg DeBruijnPattern) -&gt; Match DeBruijnPattern
forall a. Simplification -&gt; IntMap (Arg a) -&gt; Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#Yes"><span class="hs-identifier hs-var">Yes</span></a></span><span> </span><span class="annot"><span class="annottext">Simplification
</span><a href="Agda.TypeChecking.Monad.Base.html#NoSimplification"><span class="hs-identifier hs-var">NoSimplification</span></a></span><span> </span><span class="annot"><span class="annottext">IntMap (Arg DeBruijnPattern)
forall a. Null a =&gt; a
</span><a href="Agda.Utils.Null.html#empty"><span class="hs-identifier hs-var">empty</span></a></span><span>
</span><span id="line-366"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#LitP"><span class="hs-identifier hs-type">LitP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match DeBruijnPattern)
</span><a href="#local-6989586621682056672"><span class="hs-identifier hs-var">termMatch</span></a></span><span> </span><span class="hs-comment">-- Literal patterns bind no variables so we can fall back to the Term version.</span><span>
</span><span id="line-367"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#DefP"><span class="hs-identifier hs-type">DefP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match DeBruijnPattern)
</span><a href="#local-6989586621682056672"><span class="hs-identifier hs-var">termMatch</span></a></span><span>
</span><span id="line-368"></span><span>
</span><span id="line-369"></span><span>    </span><span class="annot"><a href="Agda.Syntax.Internal.html#ConP"><span class="hs-identifier hs-type">ConP</span></a></span><span> </span><span id="local-6989586621682056678"><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682056678"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621682056679"><span class="annot"><span class="annottext">ConPatternInfo
</span><a href="#local-6989586621682056679"><span class="hs-identifier hs-var">cpi</span></a></span></span><span> </span><span id="local-6989586621682056680"><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621682056680"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-370"></span><span>      </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern
</span><a href="#local-6989586621682056669"><span class="hs-identifier hs-var">q</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-371"></span><span>        </span><span class="annot"><a href="Agda.Syntax.Internal.html#ConP"><span class="hs-identifier hs-type">ConP</span></a></span><span> </span><span id="local-6989586621682056681"><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682056681"><span class="hs-identifier hs-var">c'</span></a></span></span><span> </span><span class="annot"><span class="annottext">ConPatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621682056682"><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621682056682"><span class="hs-identifier hs-var">qs</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682056678"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">ConHead -&gt; ConHead -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682056681"><span class="hs-identifier hs-var">c'</span></a></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
-&gt; [Arg DeBruijnPattern] -&gt; m (Match DeBruijnPattern)
forall (m :: * -&gt; *).
MonadMatch m =&gt;
[NamedArg DeBruijnPattern]
-&gt; [Arg DeBruijnPattern] -&gt; m (Match DeBruijnPattern)
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPatternsP"><span class="hs-identifier hs-var">matchPatternsP</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621682056680"><span class="hs-identifier hs-var">ps</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">(NamedArg DeBruijnPattern -&gt; Arg DeBruijnPattern)
-&gt; [NamedArg DeBruijnPattern] -&gt; [Arg DeBruijnPattern]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">((NamedArg DeBruijnPattern -&gt; Arg DeBruijnPattern)
 -&gt; [NamedArg DeBruijnPattern] -&gt; [Arg DeBruijnPattern])
-&gt; ((Named NamedName DeBruijnPattern -&gt; DeBruijnPattern)
    -&gt; NamedArg DeBruijnPattern -&gt; Arg DeBruijnPattern)
-&gt; (Named NamedName DeBruijnPattern -&gt; DeBruijnPattern)
-&gt; [NamedArg DeBruijnPattern]
-&gt; [Arg DeBruijnPattern]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(Named NamedName DeBruijnPattern -&gt; DeBruijnPattern)
-&gt; NamedArg DeBruijnPattern -&gt; Arg DeBruijnPattern
forall a b. (a -&gt; b) -&gt; Arg a -&gt; Arg b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Named NamedName DeBruijnPattern -&gt; DeBruijnPattern
forall name a. Named name a -&gt; a
</span><a href="Agda.Syntax.Common.html#namedThing"><span class="hs-identifier hs-var">namedThing</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621682056682"><span class="hs-identifier hs-var">qs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-372"></span><span>                     </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Match DeBruijnPattern -&gt; m (Match DeBruijnPattern)
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Match DeBruijnPattern
forall a. Match a
</span><a href="Agda.TypeChecking.Patterns.Match.html#No"><span class="hs-identifier hs-var">No</span></a></span><span>
</span><span id="line-373"></span><span>        </span><span class="annot"><a href="Agda.Syntax.Internal.html#LitP"><span class="hs-identifier hs-type">LitP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(DeBruijnPattern -&gt; DeBruijnPattern)
-&gt; Match DeBruijnPattern -&gt; Match DeBruijnPattern
forall a b. (a -&gt; b) -&gt; Match a -&gt; Match b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern -&gt; DeBruijnPattern
forall {x} {a}. Pattern' x -&gt; Pattern' a
</span><a href="#local-6989586621682056685"><span class="hs-identifier hs-var">toLitP</span></a></span><span> </span><span class="annot"><span class="annottext">(Match DeBruijnPattern -&gt; Match DeBruijnPattern)
-&gt; m (Match DeBruijnPattern) -&gt; m (Match DeBruijnPattern)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">m (Match DeBruijnPattern)
</span><a href="#local-6989586621682056672"><span class="hs-identifier hs-var">termMatch</span></a></span><span>
</span><span id="line-374"></span><span>          </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621682056685"><span class="annot"><span class="annottext">toLitP :: Pattern' x -&gt; Pattern' a
</span><a href="#local-6989586621682056685"><span class="hs-identifier hs-var hs-var">toLitP</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#DotP"><span class="hs-identifier hs-type">DotP</span></a></span><span> </span><span class="annot"><span class="annottext">PatternInfo
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.Syntax.Internal.html#Lit"><span class="hs-identifier hs-type">Lit</span></a></span><span> </span><span id="local-6989586621682056688"><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621682056688"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Literal -&gt; Pattern' a
forall a. Literal -&gt; Pattern' a
</span><a href="Agda.Syntax.Internal.html#litP"><span class="hs-identifier hs-var">litP</span></a></span><span> </span><span class="annot"><span class="annottext">Literal
</span><a href="#local-6989586621682056688"><span class="hs-identifier hs-var">l</span></a></span><span>   </span><span class="hs-comment">-- All bindings should be to literals</span><span>
</span><span id="line-375"></span><span>                </span><span class="annot"><a href="#local-6989586621682056685"><span class="hs-identifier hs-var">toLitP</span></a></span><span> </span><span class="annot"><span class="annottext">Pattern' x
</span><span class="hs-identifier">_</span></span><span>                </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pattern' a
forall a. HasCallStack =&gt; a
</span><a href="Agda.Utils.Impossible.html#__IMPOSSIBLE__"><span class="hs-identifier hs-var">__IMPOSSIBLE__</span></a></span><span>
</span><span id="line-376"></span><span>        </span><span class="annot"><span class="annottext">DeBruijnPattern
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">m (Match DeBruijnPattern)
</span><a href="#local-6989586621682056672"><span class="hs-identifier hs-var">termMatch</span></a></span><span>
</span><span id="line-377"></span><span>
</span><span id="line-378"></span><span id="local-6989586621682055922"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#matchPatternsP"><span class="hs-identifier hs-type">matchPatternsP</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#MonadMatch"><span class="hs-identifier hs-type">MonadMatch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055922"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-379"></span><span>               </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Common.html#NamedArg"><span class="hs-identifier hs-type">NamedArg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-identifier hs-type">DeBruijnPattern</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-380"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Agda.Syntax.Common.html#Arg"><span class="hs-identifier hs-type">Arg</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-identifier hs-type">DeBruijnPattern</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-381"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682055922"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#DeBruijnPattern"><span class="hs-identifier hs-type">DeBruijnPattern</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-382"></span><span id="matchPatternsP"><span class="annot"><span class="annottext">matchPatternsP :: forall (m :: * -&gt; *).
MonadMatch m =&gt;
[NamedArg DeBruijnPattern]
-&gt; [Arg DeBruijnPattern] -&gt; m (Match DeBruijnPattern)
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPatternsP"><span class="hs-identifier hs-var hs-var">matchPatternsP</span></a></span></span><span> </span><span id="local-6989586621682056698"><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621682056698"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span id="local-6989586621682056699"><span class="annot"><span class="annottext">[Arg DeBruijnPattern]
</span><a href="#local-6989586621682056699"><span class="hs-identifier hs-var">qs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-383"></span><span>  </span><span class="annot"><span class="annottext">[Match DeBruijnPattern] -&gt; Match DeBruijnPattern
forall a. Monoid a =&gt; [a] -&gt; a
</span><span class="hs-identifier hs-var">mconcat</span></span><span> </span><span class="annot"><span class="annottext">([Match DeBruijnPattern] -&gt; Match DeBruijnPattern)
-&gt; m [Match DeBruijnPattern] -&gt; m (Match DeBruijnPattern)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">(DeBruijnPattern
 -&gt; Arg DeBruijnPattern -&gt; m (Match DeBruijnPattern))
-&gt; [DeBruijnPattern]
-&gt; [Arg DeBruijnPattern]
-&gt; m [Match DeBruijnPattern]
forall (m :: * -&gt; *) a b c.
Applicative m =&gt;
(a -&gt; b -&gt; m c) -&gt; [a] -&gt; [b] -&gt; m [c]
</span><span class="hs-identifier hs-var">zipWithM</span></span><span> </span><span class="annot"><span class="annottext">DeBruijnPattern -&gt; Arg DeBruijnPattern -&gt; m (Match DeBruijnPattern)
forall (m :: * -&gt; *).
MonadMatch m =&gt;
DeBruijnPattern -&gt; Arg DeBruijnPattern -&gt; m (Match DeBruijnPattern)
</span><a href="Agda.TypeChecking.Patterns.Match.html#matchPatternP"><span class="hs-identifier hs-var">matchPatternP</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(NamedArg DeBruijnPattern -&gt; DeBruijnPattern)
-&gt; [NamedArg DeBruijnPattern] -&gt; [DeBruijnPattern]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">NamedArg DeBruijnPattern -&gt; DeBruijnPattern
forall a. NamedArg a -&gt; a
</span><a href="Agda.Syntax.Common.html#namedArg"><span class="hs-identifier hs-var">namedArg</span></a></span><span> </span><span class="annot"><span class="annottext">[NamedArg DeBruijnPattern]
</span><a href="#local-6989586621682056698"><span class="hs-identifier hs-var">ps</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Arg DeBruijnPattern]
</span><a href="#local-6989586621682056699"><span class="hs-identifier hs-var">qs</span></a></span><span>
</span><span id="line-384"></span><span>
</span><span id="line-385"></span><span>
</span><span id="line-386"></span><span class="annot"><span class="hs-comment">-- | Does the pattern perform a match that could fail?</span></span><span>
</span><span id="line-387"></span><span id="local-6989586621682055933"><span id="local-6989586621682055934"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#properlyMatching"><span class="hs-identifier hs-type">properlyMatching</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Signature.html#HasConstInfo"><span class="hs-identifier hs-type">HasConstInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055933"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Pattern%27"><span class="hs-identifier hs-type">Pattern'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055934"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682055933"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span><span>
</span><span id="line-388"></span><span id="properlyMatching"><span class="annot"><span class="annottext">properlyMatching :: forall (m :: * -&gt; *) a. HasConstInfo m =&gt; Pattern' a -&gt; m Bool
</span><a href="Agda.TypeChecking.Patterns.Match.html#properlyMatching"><span class="hs-identifier hs-var hs-var">properlyMatching</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Pattern' a -&gt; m Bool
forall (m :: * -&gt; *) a.
HasConstInfo m =&gt;
Bool -&gt; Bool -&gt; Pattern' a -&gt; m Bool
</span><a href="Agda.TypeChecking.Patterns.Match.html#properlyMatching%27"><span class="hs-identifier hs-var">properlyMatching'</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-389"></span><span>
</span><span id="line-390"></span><span id="local-6989586621682055937"><span id="local-6989586621682055938"><span class="annot"><a href="Agda.TypeChecking.Patterns.Match.html#properlyMatching%27"><span class="hs-identifier hs-type">properlyMatching'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Agda.TypeChecking.Monad.Signature.html#HasConstInfo"><span class="hs-identifier hs-type">HasConstInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055937"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-391"></span><span>  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>       </span><span class="annot"><span class="hs-comment">-- ^ Should absurd patterns count as proper match?</span></span><span>
</span><span id="line-392"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>       </span><span class="annot"><span class="hs-comment">-- ^ Should projection patterns count as proper match?</span></span><span>
</span><span id="line-393"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Agda.Syntax.Internal.html#Pattern%27"><span class="hs-identifier hs-type">Pattern'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621682055938"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ The pattern.</span></span><span>
</span><span id="line-394"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621682055937"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span><span>
</span><span id="line-395"></span><span id="properlyMatching%27"><span class="annot"><span class="annottext">properlyMatching' :: forall (m :: * -&gt; *) a.
HasConstInfo m =&gt;
Bool -&gt; Bool -&gt; Pattern' a -&gt; m Bool
</span><a href="Agda.TypeChecking.Patterns.Match.html#properlyMatching%27"><span class="hs-identifier hs-var hs-var">properlyMatching'</span></a></span></span><span> </span><span id="local-6989586621682056730"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682056730"><span class="hs-identifier hs-var">absP</span></a></span></span><span> </span><span id="local-6989586621682056731"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682056731"><span class="hs-identifier hs-var">projP</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-396"></span><span>  </span><span id="local-6989586621682056732"><span class="annot"><span class="annottext">Pattern' a
</span><a href="#local-6989586621682056732"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682056730"><span class="hs-identifier hs-var">absP</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Pattern' a -&gt; Maybe PatOrigin
forall x. Pattern' x -&gt; Maybe PatOrigin
</span><a href="Agda.Syntax.Internal.html#patternOrigin"><span class="hs-identifier hs-var">patternOrigin</span></a></span><span> </span><span class="annot"><span class="annottext">Pattern' a
</span><a href="#local-6989586621682056732"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe PatOrigin -&gt; Maybe PatOrigin -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">PatOrigin -&gt; Maybe PatOrigin
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">PatOrigin
</span><a href="Agda.Syntax.Internal.html#PatOAbsurd"><span class="hs-identifier hs-var">PatOAbsurd</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; m Bool
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-397"></span><span>  </span><span class="annot"><a href="Agda.Syntax.Internal.html#ConP"><span class="hs-identifier hs-type">ConP</span></a></span><span> </span><span id="local-6989586621682056735"><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682056735"><span class="hs-identifier hs-var">con</span></a></span></span><span> </span><span id="local-6989586621682056736"><span class="annot"><span class="annottext">ConPatternInfo
</span><a href="#local-6989586621682056736"><span class="hs-identifier hs-var">ci</span></a></span></span><span> </span><span id="local-6989586621682056737"><span class="annot"><span class="annottext">[NamedArg (Pattern' a)]
</span><a href="#local-6989586621682056737"><span class="hs-identifier hs-var">ps</span></a></span></span><span>    </span><span class="hs-comment">-- eta record constructors do not count as proper matches themselves</span><span>
</span><span id="line-398"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">ConPatternInfo -&gt; Bool
</span><a href="Agda.Syntax.Internal.html#conPRecord"><span class="hs-identifier hs-var">conPRecord</span></a></span><span> </span><span class="annot"><span class="annottext">ConPatternInfo
</span><a href="#local-6989586621682056736"><span class="hs-identifier hs-var">ci</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe (QName, RecordData) -&gt; Bool
forall a. Maybe a -&gt; Bool
</span><span class="hs-identifier hs-var">isNothing</span></span><span> </span><span class="annot"><span class="annottext">(Maybe (QName, RecordData) -&gt; Bool)
-&gt; m (Maybe (QName, RecordData)) -&gt; m Bool
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">QName -&gt; m (Maybe (QName, RecordData))
forall (m :: * -&gt; *).
(HasCallStack, HasConstInfo m) =&gt;
QName -&gt; m (Maybe (QName, RecordData))
</span><a href="Agda.TypeChecking.Records.html#isEtaRecordConstructor"><span class="hs-identifier hs-var">isEtaRecordConstructor</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ConHead -&gt; QName
</span><a href="Agda.Syntax.Internal.html#conName"><span class="hs-identifier hs-var">conName</span></a></span><span> </span><span class="annot"><span class="annottext">ConHead
</span><a href="#local-6989586621682056735"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">m Bool -&gt; m Bool -&gt; m Bool
forall (m :: * -&gt; *). Monad m =&gt; m Bool -&gt; m Bool -&gt; m Bool
</span><a href="Agda.Utils.Monad.html#or2M"><span class="hs-operator hs-var">`or2M`</span></a></span><span> </span><span class="annot"><span class="annottext">(NamedArg (Pattern' a) -&gt; m Bool)
-&gt; [NamedArg (Pattern' a)] -&gt; m Bool
forall (f :: * -&gt; *) (m :: * -&gt; *) a.
(Foldable f, Monad m) =&gt;
(a -&gt; m Bool) -&gt; f a -&gt; m Bool
</span><a href="Agda.Utils.Monad.html#anyM"><span class="hs-identifier hs-var">anyM</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Pattern' a -&gt; m Bool
forall (m :: * -&gt; *) a. HasConstInfo m =&gt; Pattern' a -&gt; m Bool
</span><a href="Agda.TypeChecking.Patterns.Match.html#properlyMatching"><span class="hs-identifier hs-var">properlyMatching</span></a></span><span> </span><span class="annot"><span class="annottext">(Pattern' a -&gt; m Bool)
-&gt; (NamedArg (Pattern' a) -&gt; Pattern' a)
-&gt; NamedArg (Pattern' a)
-&gt; m Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">NamedArg (Pattern' a) -&gt; Pattern' a
forall a. NamedArg a -&gt; a
</span><a href="Agda.Syntax.Common.html#namedArg"><span class="hs-identifier hs-var">namedArg</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[NamedArg (Pattern' a)]
</span><a href="#local-6989586621682056737"><span class="hs-identifier hs-var">ps</span></a></span><span>
</span><span id="line-399"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; m Bool
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-400"></span><span>  </span><span class="annot"><a href="Agda.Syntax.Internal.html#LitP"><span class="hs-identifier hs-type">LitP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; m Bool
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-401"></span><span>  </span><span class="annot"><a href="Agda.Syntax.Internal.html#DefP"><span class="hs-identifier hs-type">DefP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; m Bool
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-402"></span><span>  </span><span class="annot"><a href="Agda.Syntax.Internal.html#ProjP"><span class="hs-identifier hs-type">ProjP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; m Bool
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621682056731"><span class="hs-identifier hs-var">projP</span></a></span><span>
</span><span id="line-403"></span><span>  </span><span class="annot"><a href="Agda.Syntax.Internal.html#VarP"><span class="hs-identifier hs-type">VarP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; m Bool
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-404"></span><span>  </span><span class="annot"><a href="Agda.Syntax.Internal.html#DotP"><span class="hs-identifier hs-type">DotP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; m Bool
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-405"></span><span>  </span><span class="annot"><a href="Agda.Syntax.Internal.html#IApplyP"><span class="hs-identifier hs-type">IApplyP</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; m Bool
forall a. a -&gt; m a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-406"></span></pre></body></html>